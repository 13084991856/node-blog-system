/*
 Navicat Premium Data Transfer

 Source Server         : localhost-mysql
 Source Server Type    : MySQL
 Source Server Version : 50553
 Source Host           : 127.0.0.1:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50553
 File Encoding         : 65001

 Date: 22/06/2021 09:46:47
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标题',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章内容',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `user_id` int(10) UNSIGNED NULL DEFAULT NULL COMMENT '作者id',
  `state` int(11) NOT NULL DEFAULT 0 COMMENT '删除状态 0为未删除，1为已删除',
  `classify_id01` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类id  01',
  `class_name01` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类名称1',
  `classify_id02` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类id 02',
  `class_name02` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类名称2',
  `classify_id03` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类id 03',
  `class_name03` varchar(45) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类名称3',
  `type` int(11) NULL DEFAULT 0 COMMENT '文章类型：默认0为技术文章，1为生活说说',
  `pic_url` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章封面',
  `visited` int(11) NULL DEFAULT 1 COMMENT '文章访问量',
  `like_count` int(11) NULL DEFAULT 0 COMMENT '点赞数量',
  `islike` tinyint(4) NULL DEFAULT 0 COMMENT '当前用户是否点赞了，默认为0,已点赞则为1',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `id_UNIQUE`(`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 215 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (93, '2021年初级Vue面试题目', '#### 1.var let const 的区别\n\nvar 会变量提升 let 和 const 不会\nvar 在全局命名的变量会挂载到 window 上，let const 不会\nlet 和 const 有块级作用域（暂时性死去），var 没有\nlet const 不允许重复命名\n\n#### 2.Vue 里面 computed 是什么东西怎么用？\n\n在 vue 模板里面是有表达式是非常便利的，但是设计他们的初衷是用来简单运算的。在实际的开发过程中在模板里放入过多的表达式会让项目的可维护性大大降低。\n```html\n<div>\n{{ data.split(\'\') ? data.split(\'\').reverse().join(\'\') : data.split(\'\')}}\n</div>\n```\n对于这种复杂的计算单数据，我们应该使用计算属性来解决；\n计算属性中的方法是依赖于其中的值的，当计算属性中的值变化的时候，计算属性会更新\n```js\nvar vm = new Vue({\n  el: \'#example\',\n  data: {\n  data: \'Hello\'\n  },\n  computed: {\n    // 计算属性的getter\n    reversedMessage: function () {\n    // `this` 指向 vm 实例\n    return this.data.split(\'\').reverse().join(\'\')\n    }\n  }\n})\n```\n当 this.data 的值发生变化大时候，他所依赖的计算属性 reversedMessage 会重新计算并调用\n\n#### 3.Vue 里面的 watch 是什么东西怎么使用？\n\n虽然计算属性在大部分情况下都适用，但是在实际开发过程中需要一些自定义的监听器，当需要在执行异步或者开销比较大的操作中，监听器比计算属性更加有效。\n\n```js\nwatch：{\n  //需要监听的值\n  question（）{\n\n  }\n}\n```\n#### 4.watch和computed的区别\n\n\n>计算属性和监听属性都是希望在依赖数据变化的时候，被依赖的数据根据事先设定好的函数发生自动的变换。 watch 一个数据相应多个数据 computed 一个数据受到多个数据的影响 在实现原理上watch和computed是差不多的，vue 的data值在初始化阶段都会被挂载上 watcher 观察者模式，当数据改变的时候先调用watcher观察者模式，然后调用计算属性，和监听属性。本质上来说没有多大区别\n\n#### 5.请说出 vue 几种常用的指令\n\nv-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。\n\nv-show：根据表达式之真假值，切换元素的 display CSS 属性。\n\nv-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0 以上必须需配合 key 值 使用。\n\nv-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。\n\nv-on：用于监听指定元素的 DOM 事件，比如点击事件。绑定事件监听器。\n\nv-model：实现表单输入和应用状态之间的双向绑定\n\nv-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始\n\nMustache 标签。跳过大量没有指令的节点会加快编译。\n\nv-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n#### 6.v-if 和 v-show 有什么区别\n\n**共同点：**\n\nv-if 和 v-show 都是动态显示 DOM 元素。\n\n**区别：**\n\n1、编译过程： v-if 是 真正 的 条件渲染，因为它会确保在切换过程中条件块 内的事件监听器和子组件适当地被销毁和重建。v-show 的元素始终会被渲染并 保留在 DOM 中。 v-show 只是简单地切换元素的 CSS 属性 display。\n\n2、编译条件： v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直 到条件第一次变为真时，才会开始渲染条件块。v-show 不管初始条件是什么， 元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n3、性能消耗： v-if 有更高的切换消耗。v-show 有更高的初始渲染消耗。\n\n4、应用场景： v-if 适合运行时条件很少改变时使用。v-show 适合频繁切换。\n\n#### 7.vue 中子组件调用父组件的方法\n通过 v-on 监听 和emit\'触发 当前实例上的 自定义事件。 示例： 父组件：\n```html\n<template>\n  <div class=\"fatherPageWrap\">\n  <h1>这是父组件</h1>\n<!-- 引入子组件，v-on 监听自定义事件 -->\n  <emitChild v-on:emitMethods=\"fatherMethod\"></emitChild>\n  </div>\n</template>\n<script type=\"text/javascript\">\nimport emitChild from \'@/page/children/emitChild.vue\';\nexport default{\n  data () {\n  return {}\n  },\n  components : {\n  emitChild\n  },\n  methods : {\n    fatherMethod(params){\n      alert(JSON.stringify(params));\n    }\n  }\n}</script>\n  \n<!--子组件：-->\n\n<template>\n  <div class=\"childPageWrap\">\n    <h1>这是子组件</h1>\n  </div>\n</template>\n<script type=\"text/javascript\">\nexport default{\n  data () {\n    return {}\n  },\n  mounted () {\n  //通过 emit 触发\n  this.$emit(\'emitMethods\',{\"name\" : 123});\n  }\n}</script>\n结果：\n子组件 会调用 父组件的 fatherMethod 方法，该并且会 alert 传递过去的参\n数：{\"name\":123}\n\n```\n#### 8.axios 有哪些特点？\n\n1、Axios 是一个基于 promise 的 HTTP 库，支持 promise 所有的 API\n\n2、它可以拦截请求和响应\n\n3、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON 类 型的数据\n\n4、安全性更高，客户端支持防御 XSRF\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2021-04-12 00:00:00', 18, 0, '143', '前端面试汇总', '144', 'vue初级面试题', '145', '', 0, 'http://127.0.0.1:3000\\uploads\\20210416\\1618557785462.jpg', 250, 15, 1);
INSERT INTO `article` VALUES (94, 'router-view 组件间传值', '情况1：router-view 子组件发生变化导致父组件发生改变\n父组件中：\n\n```js\n<router-view @getMessage=\"showMsg\"></router-view>\nshowMsg (val) {   // methods方法  val即为子组件传过来的值\n  console.log(val)\n}\n```', '2021-04-12 00:00:00', 18, 0, '144', 'java', '145', '', '143', '', 0, 'http://127.0.0.1:3000\\uploads\\20210418\\1618728322625.jpg', 66, 10, 0);
INSERT INTO `article` VALUES (95, 'es6-Promise解决回调地狱', '1、什么是回调地狱?\n假如我们有很多异步事件，而这些异步事件又有很紧密的联系，比如一个异步事件要依赖另一个异步事件的返回值，看下面的：\n\n```js\n $.ajax({\n        url: \'\',\n        data: {},\n        type: \'post\',\n        dataType: JSON,\n        success: function (res) {\n            $.ajax({\n                url: \'\',\n                data: res.data,\n                type: \'post\',\n                dataType: JSON,\n                success: function (res1) {\n                    $.ajax({\n                        url: \'\',\n                        data: res1.data,\n                        type: \'post\',\n                        dataType: JSON,\n                        success: function (res2) {\n                            $.ajax({\n                                url: \'\',\n                                data: res2.data,\n                                type: \'post\',\n                                dataType: JSON,\n                                success: function (res3) {\n                                    console.log(res3)\n                                }\n                            })\n                        }\n                    })\n                }\n            })\n        }\n    })\n```\n是不是进入了一环套一环的地狱里面。我们可以简单处理下：\n\n```js\n function ajax1() {\n        $.ajax({\n            url: \'\',\n            data: {},\n            type: \'post\',\n            dataType: JSON,\n            success: function (res) {\n                ajax2(res.data)\n            }\n        })\n    }\n    function ajax2(data) {\n        $.ajax({\n            url: \'\',\n            data: data,\n            type: \'post\',\n            dataType: JSON,\n            success: function (res) {\n                ajax3(res.data)\n            }\n        })\n    }\n    function ajax3(data) {\n        $.ajax({\n            url: \'\',\n            data: data,\n            type: \'post\',\n            dataType: JSON,\n            success: function (res) {\n                console.log(res)\n            }\n        })\n    }\n    ajax1();\n```\n这样虽然把每个ajax请求放在了函数里面，不用把所有请求放在一个方法里面，但实际上还是在函数里面一层一层的嵌套来实现，很不便于阅读和维护。\n\n2、看看promise是如何解决的\npromise的出现就是为了解决异步编程中的回调问题，它提供了统一的 API\n```js\n   const ajax1 = new Promise(function (resolve,reject) {\n        $.ajax({\n            url: \'\',\n            data: {},\n            type: \'post\',\n            dataType: JSON,\n            success: function (res) {\n                resolve(res.data)\n            }\n        })\n    })\n    function ajax2 (data) {\n        return new Promise(function (resolve,reject) {\n            $.ajax({\n                url: \'\',\n                data: data,\n                type: \'post\',\n                dataType: JSON,\n                success: function (res) {\n                    resolve(res.data)\n                }\n            })\n        })\n    }\n    function ajax3 (data) {\n        return new Promise(function (resolve,reject) {\n            $.ajax({\n                url: \'\',\n                data: data,\n                type: \'post\',\n                dataType: JSON,\n                success: function (res) {\n                    resolve(res.data)\n                }\n            })\n        })\n    }\n    ajax1.then(function (data) {\n        return ajax2(data)\n    }).then(function (data) {\n        return ajax3(data)\n    })\n```\n这就很很好的解决了回调地狱的问题', '2021-04-12 00:00:00', 18, 0, '146', 'es6', '147', 'Promise', '148', '', 0, 'http://127.0.0.1:3000\\uploads\\20210418\\1618728405902.jpg', 44, 9, 1);
INSERT INTO `article` VALUES (96, 'sessionStorage只能存储字符串吗？', 'sessionStorage.setItem(\'xxx\',true),取出来结果\"true\"字符串\nsessionStorage.setItem(\'xxx\',{}),取出来结果\"[object Object]\"\n怎么存别的类型？\nsessionStorage和localStorage只能存字符串，针对对象需要存储storage的话可以序列化一下达到效果：\n\nvar obj = {};\n\nsessionStorage.setItem(\'xxx\', JSON.stringify(obj)); //序列化\n\nobj = JSON.parse(sessionStorage.getItem(\'xxx\')); //这时候需要反序列化一下\n\n', '2021-04-12 00:00:00', 18, 0, '146', 'sessionStorage', '145', '字符串', '149', '后端', 0, 'http://127.0.0.1:3000\\uploads\\20210415\\1618490563294.jpg', 29, 3, 0);
INSERT INTO `article` VALUES (97, 'vue之路由钩子函数', '> vue路由钩子函数可以大致分为三类，他们的作用都是主要对路由的跳转进行控制，例如权限管理、登录判断、浏览器判断。\n\n1.全局钩子\n主要包括beforeEach和afterEach,\n\n一般有三个参数：\n\nto:router即将进入的路由对象\n\nfrom:当前导航即将离开的路由\n\nnext:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。\n\n通过beforeEach来对路由跳转做权限管理：\n\n```js\n// 设置路由\nrouter.beforeEach((to, from, next) => {\n  console.log(to, from)\n  // 跳转前判断是否需要登录\n  if (to.meta.auto) {\n    sessionStorage.setItem(\'success\', to.path)\n    if (store.getters[\'login/getLogin\']) {\n      next()\n    } else {\n      next({ path: \'pleaseLogin\' })\n    }\n  } else {\n    next()\n  }\n})\n```\nrouter.beforeEach 页面加载之前\n\nrouter.afterEach  页面加载之后\n\n2、单个路由里面的钩子\nbeforeEnter和beforeLeave\n```js\nbeforeEnter: (to, from, next) => {          \n   console.log(to,from,next)\n},\nbeforeLeave: (to, from, next) => {\n   console.log(to,from,next)\n},\n```\n3、组件路由\nbeforeRouteEnter和beforeRouteUpdate,beforeRouteLeave\n```js\n\nbeforeRouteEnter(to, from, next) {\n   console.log(to)\n},\nbeforeRouteUpdate(to, from, next) {\n   console.log(to)\n},\nbeforeRouteLeave(to, from, next) {\n   console.log(to)\n}', '2021-04-12 00:00:00', 18, 0, '146', 'vue', '145', '', '150', '', 0, 'http://127.0.0.1:3000\\uploads\\20210415\\1618490592929.jpg', 25, 3, 1);
INSERT INTO `article` VALUES (98, '使用axios发送get和post请求详解', '发送get请求\n\n方法一：\n在axios方法中直接传入一个对象，配置请求路径：url,\n传递参数：params。然后使用。.then方法获得响应数据\n\n```js\n//配置接口地址\naxios.defaults.baseURL = \'http://127.0.0.1:3000\'\nfunction testget() {\n            axios({\n                    url: \'/a\',\n                    params: {\n                        id: 1\n                    }\n                })\n                .then(response => {\n                    console.log(\'/a\', response.data)\n                    return response.data\n                }, error => {\n                    console.log(\'错误\', error.message)\n                })\n        }\ntestget()\n', '2021-04-12 00:00:00', 18, 0, '151', 'axios', '143', '前端', NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210415\\1618490625539.jpg', 24, 5, 1);
INSERT INTO `article` VALUES (99, 'cursor:pointer;', 'cursor:pointer;', '2021-04-12 00:00:00', 18, 0, NULL, 'vue', NULL, '前端', NULL, '后端', 0, 'http://127.0.0.1:3000\\uploads\\20210420\\1618917611885.jpg', 36, 9, 1);
INSERT INTO `article` VALUES (100, '23 个 Vue.js 初级面试题', '#### 1. 为什么Vue被称为“渐进框架”？\n\n使用渐进式框架的代价很小，从而使现有项目（使用其他技术构建的项目）更容易采用并迁移到新框架。 Vue.js 是一个渐进式框架，因为你可以逐步将其引入现有应用，而不必从头开始重写整个程序。\n\nVue 的最基本和核心的部分涉及“视图”层，因此可以通过逐步将 Vue 引入程序并替换“视图”实现来开始你的旅程。\n\n由于其不断发展的性质，Vue 与其他库配合使用非常好，并且非常容易上手。这与 Angular.js 之类的框架相反，后者要求将现有程序完全重构并在该框架中实现。\n\n#### 2. Vue.js 中的声明式渲染是什么？\n\nVue.js 使渲染数据变得容易，并隐藏了内部实现。例如下面的代码：\n\n**HTML**\n```html\n<div id=\'app\'></div>\n```\n**JavaScript**\n```js\nconst greeting = “Hello there!”;\nconst appDiv = document.getElementById(“app”);\nappDiv.innerText = greeting;\n```\n上面的代码段将在 ID 为 “app” 的 div 中显示短语 “Hello there！”。代码包含实现结果所需的所有步骤。首先选择 ID 为 “app” 的 DOM 元素，然后用 innerText 属性手动设置 div 的内容。\n\n现在，让我们看看在 Vue 中是怎么做的。\n\n**Template**\n```html\n<div id=\'app\'>{{ greeting }}</div>\n```\n**App**\n\n```js\nnew Vue({\n    data: {\n       greeting: ‘Hello There!’\n    },\n   el: ‘#app’\n});\n```\n我们在 Vue 程序中创建了一个名为 “greeting” 的数据属性，但是只需要在 div 中用 mustache 语法输入 “greeting” 即可，而不必关心内部实现。我们声明了 “greeting” 变量，其余的由 Vue 完成。这就是声明式渲染的样子。 Vue 隐藏并管理内部信息。\n\n\n', '2021-04-13 00:00:00', 18, 0, '143', '前端面试汇总', NULL, 'vue初级面试题', NULL, '', 0, 'http://127.0.0.1:3000\\uploads\\20210416\\1618554635762.jpg', 22, 7, 1);
INSERT INTO `article` VALUES (101, '一个人最好的生活状态', '一个人最好的生活状态，是该看书时看书，该玩时尽情玩，看见优秀的人欣赏，看到落魄的人也不轻视，有自己的小生活和小情趣，不用去想改变世界，努力去活出自己。没人爱时专注自己，有人爱时，有能力拥抱彼此。', '2021-04-13 00:00:00', 18, 0, '152', '生活', NULL, NULL, NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210415\\1618490908200.jpg', 31, 12, 1);
INSERT INTO `article` VALUES (102, '又写了一天的代码', '又写了一天的代码', '2021-04-13 00:00:00', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, 'http://127.0.0.1:3000\\uploads\\20210416\\1618576192492.jpg', 2, 3, 1);
INSERT INTO `article` VALUES (110, '', '这个博客网站的制作，是迈向职业程序员的第一步', '2021-04-13 19:02:44', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 0, 2, 0);
INSERT INTO `article` VALUES (111, '', '“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n::: hljs-right\n\n——网易云热评《红莓花儿开》 ​​​ ​​​​\n\n:::\n\n\n\n', '2021-04-13 19:09:42', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 0, 2, 0);
INSERT INTO `article` VALUES (112, '', '“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n\n\n——网易云热评《红莓花儿开》 ​​​ ​​​​\n\n\n\n\n', '2021-04-13 19:10:23', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 0, 2, 0);
INSERT INTO `article` VALUES (113, '学习使我快乐', '学习使我快乐', '2021-04-13 19:13:23', 18, 0, '152', '生活', NULL, NULL, NULL, NULL, 1, NULL, 1, 2, 0);
INSERT INTO `article` VALUES (114, '', '“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n\n\n::: hljs-right\n\n——网易云热评《红莓花儿开》 ​​​ ​​​​\n\n:::\n\n\n\n\n\n', '2021-04-13 19:16:01', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 2, 0);
INSERT INTO `article` VALUES (115, '', '“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n2、“未成定局的事就不要弄的人尽皆知” ​​​​\n\n3、“大胆点生活 你没那么多观众” ​​​​\n“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n2、“未成定局的事就不要弄的人尽皆知” ​​​​\n\n3、“大胆点生活 你没那么多观众” ​​​​\n“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n2、“未成定局的事就不要弄的人尽皆知” ​​​​\n\n3、“大胆点生活 你没那么多观众” ​​​​\n“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n2、“未成定局的事就不要弄的人尽皆知” ​​​​\n\n3、“大胆点生活 你没那么多观众” ​​​​\n“小时候不理解老人晒太阳，一坐就是半天。长大了才明白，目之所及皆是回忆，心之所想皆是过往，眼之所看皆是遗憾。”\n\n2、“未成定局的事就不要弄的人尽皆知” ​​​​\n\n3、“大胆点生活 你没那么多观众” ​​​​', '2021-04-13 19:21:03', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 0, 2, 0);
INSERT INTO `article` VALUES (116, '', '停练半个月，又开始健身了', '2021-04-13 22:17:07', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 0, 2, 0);
INSERT INTO `article` VALUES (117, '', '\n人生最大的自由，不是想做什么就做什么，而是，想不做什么就不做什么。\n\n——网易云热评《自由の翼》\n\n\n![](https://pic2.zhimg.com/80/v2-219a8299db137c44ba6741a7ef6c5daa_720w.jpg?source=1940ef5c)\n\n\n\n\n\n\n\n\n\n\n\n', '2021-04-13 22:20:49', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 2, 0);
INSERT INTO `article` VALUES (118, '下雨特效', '##### 本站的下雨特效代码，canvas实现。\n\n```js\n  <body>\n    <script src=\"https://www.luckyclover.top/rain.js\"></script>\n    <script>Rain({speed:[2,40],hasBounce:true,wind_direction:340,gravity:0.05,maxNum:80,numLevel:5,drop_chance:0.4,cloud:true});</script>\n  </body>\n```\n\n', '2021-04-13 23:09:04', 18, 0, '153', 'CSS', '154', '特效', NULL, NULL, 1, NULL, 0, 2, 0);
INSERT INTO `article` VALUES (119, '【造轮子】原生JavaScript实现轮播图', '```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        ul,\n        li {\n            padding: 0;\n            margin: 0;\n        }\n        \n        a {\n            font-style: normal;\n            padding: 0;\n            margin: 0;\n        }\n        \n        li {\n            list-style: none;\n        }\n        /* 四个圈圈 */\n        \n        ol {\n            padding: 0;\n            display: flex;\n            position: absolute;\n            bottom: 0px;\n            left: 50%;\n            transform: translateX(-50%);\n        }\n        /* 两个按钮 */\n        \n        .right,\n        .left {\n            display: none;\n            position: absolute;\n            top: 50%;\n            width: 15px;\n            height: 20px;\n            line-height: 20px;\n            border: none;\n            background-color: rgba(235, 231, 231, 0.5);\n            color: white;\n        }\n        \n        .left {\n            left: 0;\n        }\n        \n        .right {\n            right: 0;\n            text-align: right\n        }\n        \n        .right span {\n            float: right;\n        }\n        \n        ol li {\n            width: 10px;\n            height: 10px;\n            background-color: rgb(179, 192, 204);\n            margin: 0 10px;\n            border-radius: 50%;\n        }\n        /* 大盒子 用于显示单张图片*/\n        \n        .main {\n            position: relative;\n            border: 1px solid black;\n            width: 500px;\n        }\n        /* 轮播图 */\n        \n        .lbtBox {\n            overflow: hidden;\n        }\n        \n        .lbt {\n            position: relative;\n            display: flex;\n            border: 1px solid red;\n        }\n        \n        .lbt li {\n            height: 323px;\n        }\n        \n        .lbt li a {\n            display: inline-block;\n            width: 100%;\n            height: 100%;\n        }\n        \n        .lbt li img {\n            width: 500px;\n            height: 100%;\n        }\n        /* 流行的某一个 */\n        \n        .current {\n            background-color: white;\n        }\n    </style>\n</head>\n\n<body>\n\n    <div class=\"main\">\n        <!-- 图片存放在ul -->\n        <div class=\"lbtBox\">\n            <ul class=\"lbt\">\n                <li>\n                    <a href=\"javascript:;\">\n                        <img src=\"./img/1.jpg\" alt=\"\">\n                    </a>\n                </li>\n                <li>\n                    <a href=\"javascript:;\">\n                        <img src=\"./img/2.jpg\" alt=\"\">\n                    </a>\n                </li>\n                <li>\n                    <a href=\"javascript:;\">\n                        <img src=\"./img/3.jpg\" alt=\"\">\n                    </a>\n                </li>\n                <li>\n                    <a href=\"javascript:;\">\n                        <img src=\"./img/4.jpg\" alt=\"\">\n                    </a>\n                </li>\n                <li>\n                    <a href=\"javascript:;\">\n                        <img src=\"./img/5.jpg\" alt=\"\">\n                    </a>\n                </li>\n\n            </ul>\n            <!-- 两个按钮 -->\n            <div class=\"left\">\n                <</div>\n                    <div class=\"right\">></div>\n\n                    <!-- 四个圆 -->\n                    <ol class=\"circle\">\n                    </ol>\n            </div>\n        </div>\n\n\n        <script>\n            function animate(obj, target, callback) {\n                // console.log(callback);  callback = function() {}  调用的时候 callback()\n                console.log(obj.timer);\n                // 先清除以前的定时器，只保留当前的一个定时器执行\n                clearInterval(obj.timer);\n                obj.timer = setInterval(function() {\n                    // 步长值写到定时器的里面\n                    // 把我们步长值改为整数 不要出现小数的问题\n                    // var step = Math.ceil((target - obj.offsetLeft) / 10);\n                    var step = (target - obj.offsetLeft) / 10;\n                    step = step > 0 ? Math.ceil(step) : Math.floor(step);\n                    if (obj.offsetLeft == target) {\n                        // 停止动画 本质是停止定时器\n                        clearInterval(obj.timer);\n                        // 回调函数写到定时器结束里面\n                        // if (callback) {\n                        //     // 调用函数\n                        //     callback();\n                        // }\n                        callback && callback();\n                    }\n                    // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10\n                    obj.style.left = obj.offsetLeft + step + \'px\';\n\n                }, 15);\n            }\n\n\n\n\n            // 功能1：鼠标经过轮播图,左右按钮显示，离开则隐藏\n            // 1.1获取元素\n            var lbtLeft = document.querySelector(\'.left\')\n            var lbtRight = document.querySelector(\'.right\')\n                // 轮播图大盒子\n            var lbtBox = document.querySelector(\'.lbtBox\')\n                // 轮播图\n            var lbt = document.querySelector(\'.lbt\')\n                // 轮播图的宽度\n            var lbtWight = lbt.offsetWidth;\n            // 1.2添加经过鼠标事件\n            lbtBox.addEventListener(\'mouseenter\', () => {\n                    lbtLeft.style.display = \'block\'\n                    lbtRight.style.display = \'block\'\n                })\n                // 1.2添加离开鼠标事件\n            lbtBox.addEventListener(\'mouseleave\', () => {\n                    lbtLeft.style.display = \'none\'\n                    lbtRight.style.display = \'none\'\n                })\n                // 功能2：动态生成小圆 小圆的个数由轮播图的li的个数决定\n            var ol = document.querySelector(\'.circle\');\n            for (var i = 0; i < lbt.children.length; i++) {\n                // 创建li\n                let li = document.createElement(\'li\');\n                // 为创建的li添加自定义属性，就是记录li的索引号\n                li.setAttribute(\'index\', i)\n                    // 把li插入到ol\n                ol.appendChild(li);\n                // 生成小圆的同时直接绑定点击事件\n                li.addEventListener(\'click\', function() {\n                    // 干掉所有人，把所有li清除 current类名\n                    for (var i = 0; i < ol.children.length; i++) {\n                        ol.children[i].className = \'\'\n                    }\n                    // 留下我自己 当前li设置 current类名\n                    this.className = \'current\'\n                        // 点击小圆， 移动的是ul\n                        // ul的移动距离 = 小圆的索引号 * 图片宽度  注意图片往右走 ，移动距离是负值\n                    var index = this.getAttribute(\'index\');\n\n                    console.log(\"距离\", -index * lbtWight);\n                    // 使用动画函数\n                    animate(lbt, -index * lbtWight)\n                    console.log(lbtWight);\n                })\n\n            }\n            // 功能3.点击右侧按钮，图片滚动一张\n            // 克隆第一张图片放到轮播图ul的最后面\n            var first = lbt.children[0].cloneNode(true);\n            lbt.appendChild(first)\n            var num = 0;\n            lbtRight.addEventListener(\'click\', function() {\n                // 当走到最后复制的图片时，将轮播图ul快速复原left改为0\n                if (num == lbt.children.length - 1) {\n                    lbt.style.left = 0;\n                    num = 0;\n                }\n                num++;\n                animate(lbt, -num * lbtWight)\n            })\n\n            // 把ol里面的第一个li设置类名为current\n            ol.children[0].className = \'current\'\n        </script>\n</body>\n\n</html>\n\n\n\n\n\n', '2021-04-14 16:13:49', 18, 0, '155', '造轮子', '156', 'JavaScript', NULL, 'HTML', 0, NULL, 0, 2, 0);
INSERT INTO `article` VALUES (120, '一万小时定律', '\n一万小时定律是作家格拉德威尔在《异类》一书中指出的定律。“人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。1万小时的锤炼是任何人从平凡变成世界级大师的必要条件。”他将此称为“一万小时定律”。\n\n要成为某个领域的专家，需要10000小时（1.1415525年），按比例计算就是：如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。这就是一万小时定律。', '2021-04-14 23:19:12', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, 'http://127.0.0.1:3000\\uploads\\20210419\\1618808090918.jpg', 3, 2, 0);
INSERT INTO `article` VALUES (121, 'CSS经典面试题（史上最全，持续更新中...）', '\n#### 1. 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\n\n盒子模型就是 元素在网页中的实际占位，有两种：**标准盒子模型和IE盒子模型**\n**标准(W3C)盒子模型：**内容content+填充padding+边框border+边界margin\n宽高指的是 content 的宽高\n**低版本IE盒子模型：**内容（content+padding+border）+ 边界margin，\n宽高指的是 content+padding+border 部分的宽高\n\n**  CSS 如何设置这两种模型？**\n```js\nbox-sizing : content-box  //标准(W3C)盒子模型\nbox-sizing : border-box	  //IE盒子模型\n```\n#### 2.box-sizing属性？\n\n用来控制元素的盒子模型的解析模式，默认为content-box\ncontext-box：**W3C的标准盒子模型**，设置元素的 height/width 属性指的是 **content** 部分的高/宽\n**border-box：**IE传统盒子模型**。**设置元素的 height/width 属性指的是 **content + border + padding** 部分的高/宽\n\n作者：Coderfei\n链接：https://juejin.cn/post/6844903832552472583\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n', '2021-04-15 17:54:35', 18, 0, NULL, '前端面试汇总', NULL, 'CSS', NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210416\\1618552285032.jpg', 11, 3, 0);
INSERT INTO `article` VALUES (148, 'vue中\'. native\'修饰符的使用', '\n官网的解释：\n\n\n> 你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native 。\n\n通俗点讲：就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加\'. native\'事件是无法触  发的。\n\n```js\n <el-form-item prop=\"password\">\n  <el-input v-model=\"form.password\" @keyup.enter=\"onSubmit\"></el-input>\n</el-form-item>\n```\n此时按回车无反应，因为vue把@keyup.enter当成了子组件传过来的事件，所以应该写成@keyup.enter.**native**=\"onSubmit\"\n```js\n <el-form-item prop=\"password\">\n    <el-input v-model=\"form.password\" @keyup.enter.native=\"onSubmit\"></el-input>\n</el-form-item>\n```\n native的作用可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，并且该修饰符对普通HTML标签是没有任何作用的。\n\n\n\n\n\n', '2021-04-18 14:03:37', 18, 0, '150', 'vue', NULL, NULL, NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210418\\1618725955821.jpg', 15, 1, 0);
INSERT INTO `article` VALUES (149, '前端ES6面试题', '**1、ES5、ES6和ES2015有什么区别?**\n\n> ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线\n\n**2、babel是什么，有什么作用?**\n> babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台\n\n**3、let有什么用，有了var为什么还要用let？**\n\n> 在ES6之前，声明变量只能用var，var方式声明变量其实是很不合理的，准确的说，是因为ES5里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如for循环var变量泄露，变量覆盖等问题。let声明的变量拥有自己的块级作用域，且修复了var声明变量带来的变量提升问题。\n\n**4、举一些ES6对String字符串类型做的常用升级优化?**\n\n**优化部分**\n> ES6新增了字符串模板，在拼接大段字符串时，用反斜杠()`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅\n\n**升级部分**\n\n> ES6在String原型上新增了includes()方法，用于取代传统的只能用indexOf查找包含字符的方法(indexOf返回-1表示没查到不如includes方法返回false更明确，语义更清晰), 此外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符串\n\n\n\n\n\n', '2021-04-18 14:34:14', 18, 0, '157', '前端面试汇总', '158', 'ES6', NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210418\\1618738950065.jpg', 9, 1, 0);
INSERT INTO `article` VALUES (151, 'CSS实现漂亮的大标题文字效果', '## HTML代码用H1吧，这样语义化好些，因为标题一般用h1-h6.\n\n```html\n<h1 class=\"vintage\">美丽的中国语</h1>\n```\n\n### CSS空心文字\n\n![](http://images.shejidaren.com/wp-content/uploads/2013/10/css-heading-02.png)\n\n```css\n.stroke{\ncolor: transparent;\n-webkit-text-stroke: 1px black;\nletter-spacing: 0.04em;\nbackground-color: }\n```\n### CSS内阴影文字效果\n\n![](http://images.shejidaren.com/wp-content/uploads/2013/10/css-heading-03.png)\n\n```css\n.press {\ncolor: transparent;\nbackground-color : black;\ntext-shadow : rgba(255,255,255,0.5) 0 5px 6px, rgba(255,255,255,0.2) 1px 3px 3px;\n-webkit-background-clip : text;\n}\n```\n### CSS 实现3D感文字标题(本站采用)\n\n![](http://images.shejidaren.com/wp-content/uploads/2013/10/css-heading-04.png)\n\n```css\n.threed{\ncolor: #fafafa;\nletter-spacing: 0;\ntext-shadow: \n0px 1px 0px #999, \n0px 2px 0px #888, \n0px 3px 0px #777, \n0px 4px 0px #666, \n0px 5px 0px #555, \n0px 6px 0px #444, \n0px 7px 0px #333, \n0px 8px 7px #001135 \n}\n```\n\n代码来自 [Tutorials ETC](http://codepen.io/AgustiBelloc/pen/bljEB)\n\n', '2021-04-19 12:50:26', 18, 0, '153', 'CSS', '159', 'CSS特效', NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210419\\1618807924418.jpg', 36, 1, 0);
INSERT INTO `article` VALUES (153, 'JavaScript reverse() 方法', '\n**定义和用法\nreverse() 方法用于颠倒数组中元素的顺序。**\n\n语法\n\n```js\narrayObject.reverse()\n```\n\n提示和注释\n注释：**该方法会改变原来的数组，而不会创建新的数组。**\n\n实例\n在本例中，我们将创建一个数组，然后颠倒其元素的顺序：\n\n```js\nvar arr = new Array(3)\narr[0] = \"George\"\narr[1] = \"John\"\narr[2] = \"Thomas\"\n\ndocument.write(arr + \"<br />\")\ndocument.write(arr.reverse())\n\n```\n\n输出：\n```js\nGeorge,John,Thomas\nThomas,John,George\n```\n\n\n补充相关知识点：\n\nJavaScript实现-字符串翻转-Reverse a String\n\n题目：翻转字符串\n思路：先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。\n\n```js\nfunction reverseString(str) {\n  var newstr = str.split(\"\").reverse().join(\"\");\n  return newstr;\n}\n', '2021-04-19 13:26:57', 18, 0, '156', 'JavaScript', '160', '数组', NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210419\\1618809856941.jpg', 13, 3, 0);
INSERT INTO `article` VALUES (154, '深入理解 JavaScript 方法集的特性与最佳实践', '# 深入理解 JavaScript 方法集的特性与最佳实践\n\n# 1 Array\n\n## 1.1 array.concat(item…)\n\nconcat 方法会产生一个新数组，它是数组的浅复制，并把一个或多个 item 附加在其后。如果 item 是一个数组，那么它的每一个元素都会被添加：\n\n```js\nvar a = [\'a\', \'b\', \'c\'];\nvar b = [\'x\', \'y\', \'z\'];\nvar c = a.concat(b, true);\nconsole.log(c);//[ \"a\", \"b\", \"c\", \"x\", \"y\", \"z\", true ]\n\n```\n\n```js\n//也可以用concat() 复制原数组并生成一个新数组\nvar a = [\'a\', \'b\', \'c\'];\nvar c = a.concat();\n//此时c是a的副本\nconsole.log(c);//[\"a\",\"b\",\"c\"]\n//c与a是不同的两个对象，他们在内存中分别被分配两块不同的空间进行存储，c仅仅是值与a相同，但是内存地址不同\nconsole.log(c == a )//false\n```\n\n### 1.2 array.join(separator)\n\njoin 方法会把一个 array 构造成一个字符串。它先把 array 中的每一个元素都构造成一个字符串，然后再用 separator 分隔符把它们连接起来。默认的 separator 是逗号 ‘,’。如果想要实现无间隔连接，可以把 separator 设置为空字符串。\n\n```js\nvar a = [\'a\', \'b\', \'c\'];\na.push(\'d\');\nconsole.log(a.join(\'\'));//abcd\n```\n\n```js\nvar a = [\'a\', \'b\', \'c\'];\na.push(\'d\');\nconsole.log(a.join());//a,b,c,d 默认为，号分割\n```\n\n\n\n## 1.3 array.pop()\n\npop 与 push 方法可以使得数组像堆栈一样工作。pop 方法会移除 array 中的最后一个元素并返回这个元素。如果 array 是空数组，那么会返回 undefined：\n\n```js\nvar a = [\'a\', \'b\', \'c\'];\nconsole.log(a.pop());//c\n```\n\n## 1.4 array.push()\n\npush 方法把一个或多个参数 item 附加到一个数组的尾部。它会修改 array。如果 item 是一个数组，它会把这个数组作为单个元素添加到数组中，并返回这个 array 的新长度值：\n\n```js\nvar a = [\'a\', \'b\', \'c\'];\nvar b = [\'x\', \'y\', \'z\'];\nconsole.log(a.push(b, true));//5\nconsole.log(a);//[ \"a\", \"b\", \"c\", Array[3], true ]\n```\n\n## 1.5 array.reverse()\n\n这个方法会反转 array 里元素的顺序，并且会修改数组本身，不会生成一个新的数组\n\n```js\nvar a = [\'a\', \'b\', \'c\'];\nvar b = a.reverse();\nconsole.log(a);//[ \"c\", \"b\", \"a\" ] a数组使用reverse()后会改变a本身的顺序\nconsole.log(b);//[ \"c\", \"b\", \"a\" ]\n```\n', '2021-04-19 14:05:24', 18, 0, '156', 'JavaScript', NULL, NULL, NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210419\\1618812322565.jpg', 26, 1, 0);
INSERT INTO `article` VALUES (155, '修改Markdown编辑器的字体大小', '### 在全局作用域下使用以下代码\n```js\n  // 改变编辑器字体大小\n  .hljs {\n    font-size: 20px;\n}\n```\n### 就这么简单的问题,我还以为不能改,所以说,遇事不要慌,多尝试,多试错,年轻人不要怕', '2021-04-19 14:13:11', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 3, 0, 0);
INSERT INTO `article` VALUES (156, '', '人生没有彩排,每一天都是现场直播.', '2021-04-19 14:30:45', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 5, 0, 0);
INSERT INTO `article` VALUES (166, 'css设计漂亮的搜索框', '## css设计漂亮的搜索框\n\n\n\n\n```js\n* {\n	box-sizing:border-box;\n}\nbody {\n	margin:0;\n	padding:0;\n	background-image:url(ydrzimages/p3.jpg);\n	font-weight:500;\n	font-family:\"Microsoft YaHei\",\"宋体\",\"Segoe UI\",\"Lucida Grande\",Helvetica,Arial,sans-serif,FreeSans,Arimo;\n}\n#container {\n	width:500px;\n	height:820px;\n	margin:0 auto;\n}\ndiv.search {\n	padding:10px 0;\n}\nform {\n	position:relative;\n	width:300px;\n	margin:0 auto;\n}\ninput,button {\n	border:none;\n	outline:none;\n}\ninput {\n	width:100%;\n	height:42px;\n	padding-left:13px;\n}\nbutton {\n	height:42px;\n	width:42px;\n	cursor:pointer;\n	position:absolute;\n}\n/*搜索框6*/\n     \n.bar6 input {\n	border:2px solid #c5464a;\n	border-radius:5px;\n	background:transparent;\n	top:0;\n	right:0;\n}\n.bar6 button {\n	background:#c5464a;\n	border-radius:0 5px 5px 0;\n	width:60px;\n	top:0;\n	right:0;\n}\n.bar6 button:before {\n	content:\"搜索\";\n	font-size:13px;\n	color:#F9F0DA;\n}\n/*搜索框7*/\n      \n.bar7 form {\n	height:42px;\n}\n.bar7 input {\n	width:250px;\n	border-radius:42px;\n	border:2px solid #324B4E;\n	background:#F9F0DA;\n	transition:.3s linear;\n	float:right;\n}\n.bar7 input:focus {\n	width:300px;\n}\n.bar7 button {\n	background:none;\n	top:-2px;\n	right:20px;\n}\n.bar7 button:before {\n	content:\"Search\";\n	font-family:FontAwesome;\n	color:#324b4e;\n}\n/*搜索框8*/\n       \n.bar8 form {\n	height:42px;\n}\n.bar8 input {\n	width:0;\n	padding:0 42px 0 15px;\n	border-bottom:2px solid transparent;\n	background:transparent;\n	transition:.3s linear;\n	position:absolute;\n	top:0;\n	right:0;\n	z-index:2;\n}\n.bar8 input:focus {\n	width:300px;\n	z-index:1;\n	border-bottom:2px solid #F9F0DA;\n}\n.bar8 button {\n	background:#683B4D;\n	top:0;\n	right:0;\n}\n.bar8 button:before {\n	content:\"Go\";\n	font-family:FontAwesome;\n	font-size:16px;\n	color:#F9F0DA;\n}\n```', '2021-04-20 17:39:59', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210420\\1618911593894.jpg', 5, 0, 0);
INSERT INTO `article` VALUES (167, 'CSS 8种让人眼前一亮的hover效果眼前一亮的HOVER效果', '## CSS 8种让人眼前一亮的hover效果眼前一亮的HOVER效果\n\n\n### 1.发送效果\n![发送效果](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831154902861-499307127.gif)\n\n```html\n\n<h1>发送效果</h1>\n    <div id=\"send_btn\">\n        <button>\n            <svg class=\"icon\" aria-hidden=\"true\">\n                <use xlink:href=\"#icon-bianji\"></use>\n            </svg>\n            send\n        </button>\n    </div>\n\n```\n\n```css\n/* 发送效果 */\n        .icon {\n            width: 1em;\n            height: 1em;\n            vertical-align: -0.15em;\n            fill: currentColor;\n            overflow: hidden;\n        }\n\n        #send_btn button {\n            background: #5f55af;\n            border: 0;\n            border-radius: 5px;\n            padding: 10px 30px 10px 20px;\n            color: white;\n            text-transform: uppercase;\n            font-weight: bold;\n        }\n\n        #send_btn button svg {\n            display: inline-block;\n            vertical-align: middle;\n            padding-right: 5px;\n        }\n\n        #send_btn button:hover svg {\n\n            animation: fly 2s 1;\n        }\n\n        @keyframes fly {\n            0% {\n                transform: translateX(0%);\n            }\n\n            50% {\n                transform: translateX(400%);\n            }\n\n            100% {\n                transform: translateX(0);\n            }\n        }\n\n\n```\n### 2.霓虹效果\n\n![](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831154919944-1642655002.gif)\n\n```html\n<h1>霓虹效果</h1>\n\n    <div id=\"neon-btn\">\n        <button class=\"btn one\">Hover me</button>\n        <button class=\"btn two\">Hover me</button>\n        <button class=\"btn three\">Hover me</button>\n    </div>\n```\n\n```css\n/* 霓虹效果 */\n\n        #none-btn {\n            display: flex;\n            align-items: center;\n            justify-content: space-around;\n            height: 100vh;\n            background: #031628;\n        }\n\n        .btn {\n            border: 1px solid;\n            background-color: transparent;\n            text-transform: uppercase;\n            font-size: 14px;\n            padding: 10px 20px;\n            font-weight: 300;\n        }\n\n        .one {\n            color: #4cc9f0;\n        }\n\n        .two {\n            color: #f038ff;\n        }\n\n        .three {\n            color: #b9e769;\n        }\n\n        .btn:hover {\n            color: white;\n            border: 0;\n        }\n\n        .one:hover {\n            background-color: #4cc9f0;\n            -webkit-box-shadow: 10px 10px 99px 6px rgba(76, 201, 240, 1);\n            -moz-box-shadow: 10px 10px 99px 6px rgba(76, 201, 240, 1);\n            box-shadow: 10px 10px 99px 6px rgba(76, 201, 240, 1);\n        }\n\n        .two:hover {\n            background-color: #f038ff;\n            -webkit-box-shadow: 10px 10px 99px 6px rgba(240, 56, 255, 1);\n            -moz-box-shadow: 10px 10px 99px 6px rgba(240, 56, 255, 1);\n            box-shadow: 10px 10px 99px 6px rgba(240, 56, 255, 1);\n        }\n\n        .three:hover {\n            background-color: #b9e769;\n            -webkit-box-shadow: 10px 10px 99px 6px rgba(185, 231, 105, 1);\n            -moz-box-shadow: 10px 10px 99px 6px rgba(185, 231, 105, 1);\n            box-shadow: 10px 10px 99px 6px rgba(185, 231, 105, 1);\n        }\n\n\n```\n\n### 3.边框效果\n\n![](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831154934932-102426851.gif)\n\n```html\n<h1>边框效果</h1>\n    <div id=\"draw-border\">\n        <button>Hover me</button>\n    </div>\n```\n\n```css\n/* 边框效果 */\n        #draw-border button {\n            border: 1px solid #ccc;\n            background: none;\n            text-transform: uppercase;\n            color: #4361ee;\n            font-weight: bold;\n            position: relative;\n            outline: none;\n            padding: 10px 20px;\n            box-sizing: border-box;\n        }\n\n\n        #draw-border button::before,\n        button::after {\n            box-sizing: inherit;\n            position: absolute;\n            content: \'\';\n            border: 2px solid transparent;\n            width: 0;\n            height: 0;\n        }\n\n        #draw-border button::after {\n            bottom: 0;\n            right: 0;\n        }\n\n        #draw-border button::before {\n            top: 0;\n            left: 0;\n        }\n\n        #draw-border button:hover::before,\n        button:hover::after {\n            width: 100%;\n            height: 100%;\n        }\n\n        #draw-border button:hover::before {\n            border-top-color: #4361ee;\n            border-right-color: #4361ee;\n            transition: width 0.3s ease-out, height 0.3s ease-out 0.3s;\n        }\n\n        #draw-border button:hover::after {\n            border-bottom-color: #4361ee;\n            border-left-color: #4361ee;\n            transition: border-color 0s ease-out 0.6s, width 0.3s ease-out 0.6s, height 0.3s ease-out 1s;\n        }\n\n```\n\n### 4.圆形效果\n\n![](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831154953141-96097506.gif)\n\n```html\n <h1>圆形效果</h1>\n    <div id=\"circle-btn\">\n        <div class=\"btn-container\">\n            <svg class=\"icon\" aria-hidden=\"true\">\n                <use xlink:href=\"#icon-bianji\"></use>\n            </svg>\n            <button>Hover me</button>\n        </div>\n    </div>\n```\n\n```css\n/* 圆形效果 */\n        #circle-btn {\n            overflow: hidden;\n        }\n\n        #circle-btn .btn-container {\n            position: relative;\n        }\n\n        #circle-btn button {\n            border: 0;\n            border-radius: 50px;\n            color: white;\n            background: #5f55af;\n            padding: 10px 20px 7px 60px;\n            text-transform: uppercase;\n            background: linear-gradient(to right, #f72585 50%, #5f55af 50%);\n            background-size: 200% 100%;\n            background-position: right bottom;\n            transition: all 2s ease;\n        }\n\n        #circle-btn svg {\n            background: #f72585;\n            padding: 8px;\n            border-radius: 50%;\n            position: absolute;\n            left: 0;\n            top: 0%;\n        }\n\n        #circle-btn button:hover {\n            background-position: left bottom;\n        }\n\n```\n### 5.圆角效果\n\n![](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831155008870-1765660683.gif)\n\n```html\n<h1>圆角效果</h1>\n    <div id=\"border-btn\">\n        <button>Hover me</button>\n    </div>\n```\n\n```css\n/* 圆角效果 */\n\n        #border-btn button {\n            border: 0;\n            border-radius: 10px;\n            background: #2ec4b6;\n            text-transform: uppercase;\n            color: white;\n            font-size: 16px;\n            font-weight: bold;\n            padding: 15px 30px;\n            outline: none;\n            position: relative;\n            transition: border-radius 3s;\n            -webkit-transition: border-radius 3s;\n        }\n\n        #border-btn button:hover {\n            border-bottom-right-radius: 50px;\n            border-top-left-radius: 50px;\n            border-bottom-left-radius: 10px;\n            border-top-right-radius: 10px;\n        }\n```\n\n### 6.冰冻效果\n\n![](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831155025177-299409793.gif)\n\n```html\n<h1>冰冻效果</h1>\n    <div id=\"frozen-btn\">\n        <button class=\"green\">Hover me</button>\n        <button class=\"purple\">Hover me</button>\n    </div>\n```\n```css\n/* 冰冻效果 */\n        #frozen-btn button {\n            border: 0;\n            margin: 20px;\n            text-transform: uppercase;\n            font-size: 20px;\n            font-weight: bold;\n            padding: 15px 50px;\n            border-radius: 50px;\n            color: white;\n            outline: none;\n            position: relative;\n        }\n\n        #frozen-btn button:before {\n            content: \'\';\n            display: block;\n            background: linear-gradient(to left, rgba(255, 255, 255, 0) 50%, rgba(255, 255, 255, 0.4) 50%);\n            background-size: 210% 100%;\n            background-position: right bottom;\n            height: 100%;\n            width: 100%;\n            position: absolute;\n            top: 0;\n            bottom: 0;\n            right: 0;\n            left: 0;\n            border-radius: 50px;\n            transition: all 1s;\n            -webkit-transition: all 1s;\n        }\n\n        #frozen-btn .green {\n            background-image: linear-gradient(to right, #25aae1, #40e495);\n            box-shadow: 0 4px 15px 0 rgba(49, 196, 190, 0.75);\n        }\n\n        #frozen-btn .purple {\n            background-image: linear-gradient(to right, #6253e1, #852D91);\n            box-shadow: 0 4px 15px 0 rgba(236, 116, 149, 0.75);\n        }\n\n        #frozen-btn .purple:hover:before {\n            background-position: left bottom;\n        }\n\n        #frozen-btn .green:hover:before {\n            background-position: left bottom;\n        }\n\n```\n\n### 7.闪亮效果\n\n![](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831155048122-949881628.gif)\n\n```html\n<h1>闪亮效果</h1>\n \n    <div id=\"shiny-shadow\">\n        <button><span>Hover me</span></button>\n    </div>\n```\n\n```css\n #shiny-shadow{\n            background: #000;\n        }\n \n        #shiny-shadow button {\n            border: 2px solid #ccc;\n            background: transparent;\n            text-transform: uppercase;\n            color: white;\n            padding: 15px 50px;\n            outline: none;\n            overflow: hidden;\n            position: relative;\n        }\n \n        #shiny-shadow span {\n            z-index: 20;\n        }\n \n        #shiny-shadow button:after {\n            content: \'\';\n            display: block;\n            position: absolute;\n            top: -36px;\n            left: -100px;\n            background: white;\n            width: 50px;\n            height: 125px;\n            opacity: 20%;\n            transform: rotate(-45deg);\n        }\n \n        #shiny-shadow button:hover:after {\n            left: 120%;\n            transition: all 600ms cubic-bezier(0.3, 1, 0.2, 1);\n            -webkit-transition: all 600ms cubic-bezier(0.3, 1, 0.2, 1);\n        }\n```\n\n### 8.加载效果\n\n![](https://img2020.cnblogs.com/blog/1380972/202008/1380972-20200831155104215-972340878.gif)\n\n```html\n<h1>加载效果</h1>\n    \n<div id=\"loading-btn\">\n    <button><span>Hover me</span></button>\n  </div>\n```\n\n```css\n/* 加载效果 */\n#loading-btn button {\n  background: transparent;\n  border: 0;\n  border-radius: 0;\n  text-transform: uppercase;\n  font-weight: bold;\n  font-size: 20px;\n  padding: 15px 50px;\n  position: relative;\n}\n\n#loading-btn button:before {\n  transition: all 0.8s cubic-bezier(0.7, -0.5, 0.2, 2);\n  content: \'\';\n  width: 1%;\n  height: 100%;\n  background: #ff5964;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n#loading-btn button span {\n  mix-blend-mode: darken;\n}\n\n#loading-btn button:hover:before {\n  background: #ff5964;\n  width: 100%;\n}\n\n```\n\n\n\n\n\n', '2021-04-20 18:38:16', 18, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210420\\1618915129532.jpg', 20, 0, 0);
INSERT INTO `article` VALUES (168, '开始学习react框架', '**今天开始学习react框架**', '2021-06-11 13:46:07', 31, 0, '161', '说说', '162', 'react', '163', '学习', 1, NULL, 8, 0, 0);
INSERT INTO `article` VALUES (171, '库与框架', '- library(库)：小而巧，只提供特定的API，优点是可以方便的从一个库中切换到另外的库，但是代码几乎不会改变\n- Framework(框架)：大而全，框架提供了一整套的解决方案，在项目中想切换另外的框架比较困难', '2021-06-11 15:05:31', 31, 0, '164', '概念', NULL, NULL, NULL, NULL, 0, '', 4, 0, 0);
INSERT INTO `article` VALUES (172, 'react与vue对比', '## 组件化方面\n    1. 什么是模块化：是从代码的角度来分析的，把一些可以复用的代码抽离为单个的模块，便于项目的维护和开发\n    2. 什么是组件化：是从UI界面的角度来分析的，把一些可以复用的UI元素，抽离为单独的组件，便于项目的维护和开发\n    3. 组件化好处：随着项目规模的增大，手里的组件越来越多，很方便就能把现有组件，拼接成一个完整项目\n    4. Vue是如何实现组件化的：通过.vue文件来创建对应的组件\n	- template 结构\n	- script 行为\n	- style 样式\n    5. react如何实现组件化：react中一切都是以js来表现的\n## 移动App开发体验方面\n    1. vue结合Weex这门技术，提供了迁移到移动端App开发的体验\n    2. react结合ReactNative，也提供了无缝迁移到移动App的开发体验', '2021-06-11 15:33:23', 31, 0, '162', 'react', '150', 'vue', NULL, NULL, 0, '', 6, 0, 0);
INSERT INTO `article` VALUES (173, 'React中的核心概念', '### 虚拟DOM\n	1. DOM的本质是什么：浏览器中的概念，用js对象来表示页面上的元素，并提供了操作DOM对象的API\n	2. 什么是react中的虚拟DOM：是框架中的概念，是程序员用js对象来模拟页面上DOM和DOM嵌套\n	3. 为什么要实现虚拟DOM(虚拟DOM的目的)：为了实现页面中，DOM元素的高效更新\n	4. 总结：用js对象的形式，来模拟页面上DOM的嵌套关系(虚拟DOM是以对象的形式存在的)\n### Diff算法\n	1. tree diff：新旧两颗DOM树逐层对比的过程，当对比完毕，则所有需要按需更新的元素，必然能够找到\n	2. component diff：在进行tree diff的时候，每一层中组件级别的对比，如果对比前后组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上\n	3. element diff：在进行组件对比时，如果两个组件的类型相同，则需要进行元素级别的对比', '2021-06-11 15:36:19', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (174, 'React学习笔记', '## 简单使用\n	1. 导入\n		- import React from \'react\' //创建组件、虚拟DOM元素、生命周期\n		- import ReactDOM from \'react-dom\' //把创建好的组件和虚拟DOM放到页面上展示的\n	2. 创建虚拟DOM元素\n		1. const myh1 = React.createElement(\'h1\',{id:\'myh1\'},\'这是H1\')\n			- 第一个参数：元素名\n			- 第二个参数：元素的属性，可以为null\n			- 第三个参数：子节点\n	3. 使用ReactDOM把虚拟dom渲染到页面上\n		1. ReactDOM.render(myh1,document.getElementById(\'app\'))\n## 启用JSX语法\n	1. 在js中混合写入类似于HTML的语法，符合XML规范的JS\n	2. 本质还是在运行的时候转换成React.createElement()的形式\n	步骤：\n	1. 安装babel插件\n	2. 安装能够识别转换jsx语法的包\n	3. 添加.babelrc配置文件\n	4. 什么情况下使用{} ? 当需要在jsx控制的区域内写js表达式，则需要把js代码写到{}中\n	5. 把一个普通数组渲染成h5标签\n		const arrstr = [\'a\',\'b\',\'c\',\'d\']\n		在jsx区域 {arrstr.map(item => <h5 key=\"item\">{item}</h5>)}\n## 创建组件\n#### 方式一\n```javascript\n	function Hello(props) {\n	    //使用props接收数据，只读，不能赋值\n	    return <div>这是Hello组件</div>\n	}\n	//直接把组件名字以标签的形式写到render函数中渲染到页面\n\n```\n#### 方式二\n```javascript\n	class 组件名称 extends React.component {\n	    //render函数作用是渲染当前组件对应的虚拟DOM元素\n	    //在class关键字创建的组件中，如果想使用外界传递过来的props参数，不需要接收，直接通过this.props.参数名 访问\n	    //this表示当前组件的实例对象\n	    render() {\n		return <div>这是Hello组件</div>	\n	    }\n	}\n\n```\n#### 两种方式对比\n	1. class关键字创建的组件，有自己的私有数据（this.state）和生命周期函数\n	2. function创建的组件，只有props，没有自己的私有数据和生命周期函数\n	3. 构造函数创建出来的组件叫做无状态组件，效率高一些\n	4. class关键字创建出来的组件叫做有状态组件\n## 样式\n#### 组件中使用style行内,里层是对象\n	style={{color: \'red\'}}\n#### 使用css样式表\n	在react中没有类似于vue中scoped指令的概念\n	怎么解决css样式表作用域冲突问题？\n		答：在css-loader之后通过?启用模块化，有个固定参数modules\n## 绑定事件\n#### 格式\n	onClick = {function}\n#### 用得最多的事件绑定形式\n```JavaScript\n<button onClick={()=> this.show(\'传参\')}>按钮 </button>\n//事件的处理函数，需要定义一个箭头函数，然后赋值给函数名称\nshow = (arg1) => {\n    console.log(\'show方法\' + arg1)\n}\n```\n## 绑定文本框与State中的值\n#### 当为文本框绑定value值以后，要么同时提供一个readOnly，要么提供一个onChange处理函数\n```JavaScript\n<input type=\'text\' value={this.state.msg} onChange={(e)=>this.txtChange(e)} />\n\ntxtChange = (e) => {\n    console.log(\'e\',e)\n}\n/*\n默认情况下，在react中，如果页面上的表单元素，绑定了state上的状态值，那么，每当state上状态值改变，必然会自动把最新的状态值，自动同步到页面上(单向数据流)\n而如果文本框的值改变，想要把最新的值同步到state中，需要手动监听文本框的onChange事件，在onChange事件中拿到文本框最新的值，调用this.setState({})手动把最新的值同步到state中\n*/\n/*\n在onChange中获取文本框的值有两种方案\n1.通过参数e来获取 e.target.value\n2.通过this.refs\n*/\n\n```\n## 生命周期\n#### 组件创建阶段：一辈子只执行一次\n	1. componentWillMount\n	2. render\n	3. componentDidMount\n#### 组件运行阶段：按需，根据props属性或state状态的改变，有选择的执行0次或多次\n	1. componentWillReceiveProps\n	2. shouldComponentUpdate\n	3. componentWillUpdate\n	4. render\n	5. componentDidUpdate\n#### 组件销毁阶段：只执行一次\n	1. componentWillUnmount\n\n\n\n', '2021-06-11 22:41:23', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 7, 0, 0);
INSERT INTO `article` VALUES (175, '前端学习完整路线', '[前端学习路线](https://objtube.github.io/front-end-roadmap/#/)\n\n', '2021-06-12 14:09:37', 31, 0, '165', '路线', NULL, NULL, NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210619\\1624063356055.jpeg', 14, 0, 0);
INSERT INTO `article` VALUES (176, '复习阶段第一天', '复习阶段第一天', '2021-06-12 14:32:08', 31, 0, '166', '复习', NULL, NULL, NULL, NULL, 1, NULL, 6, 0, 0);
INSERT INTO `article` VALUES (177, '互联网如何工作的', '### 本地IP地址\n	当我们的电脑连入互联网后，就会获得一个IP地址\n### 什么是协议？\n	协议是一组规则，用于指定计算机应如何通过网络来相互通信\n### TCP/IP协议\n	1. 应用层：提供特定于应用程序的协议 HTTP、FTP、IMAP\n	2. 传输控制层：发送数据包到计算机上使用特定端口号的应用程序\n	3. IP网络层：使用IP地址将数据包发送到特定的计算机\n	4. 链路层：将二进制数据包与网络信号相互之间的转换\n	TCP/IP协议是一种面向连接的可靠的字节流服务协议，必须经过三次握手建立连接之后才能交换数据\n### 浏览器\n	1. 用户界面\n	2. 浏览器引擎\n	3. 渲染引擎：网络模块、Js解析器\n\n\n##### 进程和线程\n	进程：是操作系统进行资源分配和调度的基本单位，可以申请和拥有计算机资源，进程是程序的基本执行实体\n	线程：是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每个线程并行执行不同的任务', '2021-06-12 15:33:58', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 1, 0, 0);
INSERT INTO `article` VALUES (178, 'HTML5、CSS学习笔记', '## Web标准\n#### 为什么需要Web标准？\n	1. 浏览器不同，它们显示页面或者排版就有差异\n	2. 让Web发展前景更广阔\n	3. 内容能被更广泛的设备访问\n	4. 更容易被搜索引擎搜索\n	5. 降低网站流量费用\n	6. 使网站更易维护\n	7. 提高页面浏览速度\n#### Web标准构成\n	1. 结构 html\n	2. 表现 css\n	3. 行为 JavaScript\n## 标签\n#### 图像标签注意点\n	1. alt属性和title属性区别？\n		- alt是替换文本，当图片找不到时，就会将alt属性的文本替换显示出来\n		- title是提示文本，当鼠标悬浮在图像上时就会出现title提示信息\n#### 路径\n	1. 相对路径：图片相对于html页面的位置\n	2. 绝对路径：目录下的绝对位置，从盘符开始的路径\n## css元素显示模式\n#### 块元素\n	1. 独占一行\n	2. 宽度默认是父级宽度的100%\n	3. 文字类的元素内不能使用块级元素比如p、h1-h6\n#### 行内元素\n	1. 一行可以显示多个\n	2. 不能设置宽高、上下的内外边距\n	3. 默认宽度是本身内容的宽度\n	4. 链接里面不能放链接，可以放块级元素，但是转换为块级元素最安全\n#### 行内块元素\n	1. 一行上可以显示多个，它们之间默认有空白缝隙\n	2. 默认宽度是本身内容的宽度\n## 前端开发中的背景图和img标签的区别\n	1. img是html标签，是网页结构中的一部分，会随着html结构一起加载\n    ，背景图作为css样式的一部分，会在结构加载完成后开始加载。\n	2. img标签在加载失败的时候会有一个撕裂的小图标\n	3. 从后台获取的图片一般用img标签显示。\n	4. 使用img标签图片位置不好调整，而背景图片位置比较好调整\n	5. 何时使用img何时使用背景图？\n		使用img标签：\n			1.作为网页结构的一部分\n			2.图片进行缩放操作\n			3.后台传过来的数据\n			4.搜索引擎优化	\n		背景图：\n			1.小图标\n			2.超大背景图片\n## 外边距合并问题，嵌套块元素塌陷\n#### 解决方案\n	1. 父元素设置边框\n	2. 父元素设置内边距padding\n	3. 父元素设置overflow: hidden\n	4. 浮动、绝对定位、固定定位的盒子没有塌陷问题\n## 清除浮动的本质\n	1.清除浮动元素造成的影响\n	2.如果父元素本身有高度，则不需要清除浮动\n	3.清除浮动之后，父级就会根据浮动盒子自动检测高度\n#### 清除浮动方案\n	1.额外标签法：在最后一个浮动元素之后增加一个空的块级的标签，设置clear: both属性，缺点是增加了新标签，对结构不利\n	2.父级添加overflow:hidden或者overflow:auto,缺点是无法显示溢出部分\n	3.使用伪元素after，相当于额外标签法的升级版\n			.clearfix:after{\n				content: \"\";\n				display: block;\n				height: 0;\n				clear: both;\n				visibility: hidden;\n			}\n			.clearfix{\n				/*IE6、7专有*/\n				*zoom: 1;\n			}\n	4.使用双伪元素\n			.clearfix:before,.clearfix:after {\n				content: \"\";\n				display: table;\n			}\n			.clearfix: after{\n				clear: both;\n			}\n			.clearfix{\n				*zoom: 1;\n			}\n## CSS属性书写顺序\n	1.布局定位属性: display/position/float/clear/visibility/overflow\n	2.自身属性：width/height/margin/padding/border/background\n	3.文本属性: color/font/text-decoration/text-align/white-space/break-word\n	4.其他属性(CSS3): content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradlient...\n## 页面布局整体思路\n	1.必须确定页面的版心(可视区)，测量可得\n	2.分析页面中的行模块，以及每个行模块中的列模块\n	3.一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置\n	4.制作HTML结构。先有结构，后有样式\n	5.先理清楚布局结构\n## 导航栏注意点\n	1.实际开发中，我们不会直接用链接a而是用li包含链接(li+a)的做法\n	2.li+a语义更清晰，一看就是有条理的列表型内容\n	3.如果直接用a,搜索引擎容易辨别为有堆砌关键字嫌疑(故意堆砌关键字容易被搜索引擎降权的风险)，从而影响网站排名\n	注意：\n		1.让导航栏一行显示，给li加浮动，因为li是块级元素，需要一行显示\n		2.这个nav导航栏可以不给宽度，将来可以继续添加其余文字\n		3.因为导航栏里面文字不一样多，所以最好给链接a左右padding撑开盒子，而不是指定宽度\n## 搜索模块注意\n	1.button按钮会有默认边框，需要手动去掉\n	2.行内块元素之间会有默认间隙，需要添加浮动\n## 定位\n####	1.静态定位(static)\n####	2.相对定位(relative)\n	1.它是相对于自己原来的位置来移动的(移动位置的时候参照点是自己原来的位置)\n	2.原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它(不脱标，继续保留原来的位置)\n####	3.绝对定位(absolute)\n	1.如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位(Document文档)\n	2.如果祖先元素有定位(相对、绝对、固定定位)，则以最近一级的有定位祖先元素为参考点移动位置\n	3.绝对定位不再占有原先的位置(脱标)\n####	4.子绝父相\n	因为父级需要占有位置，因此使用相对定位，子盒子不需要占有位置，则使用绝对定位\n####	5.固定定位(fixed)\n	1.以浏览器的可视窗口为参照点移动元素\n		1.跟父元素没有关系\n		2.不随滚动条而滚动\n	2.固定定位不在占有原先的位置(可以看成一种特殊的绝对定位)\n	3.固定在版心右侧位置\n		1.让固定定位的盒子left:50% 走到浏览器可视区的一半位置\n		2.让固定定位的盒子margin-left:版心宽度的一半距离，多走版心宽度的一半位置\n####	6.粘性定位\n	1.以浏览器的可视窗口为参照点移动元素(固定定位特点)\n	2.粘性定位占有原先的位置(相对定位特点)\n	3.必须添加top、left、right、bottom其中一个才有效\n####	7.绝对定位的盒子居中\n	1.加了绝对定位的盒子不能通过margin:auto水平居中\n	2.left:50%;top:50%;\n	3.margin减去盒子宽高的一半\n####	8.定位特殊特性(绝对定位和固定定位也和浮动类似)\n	1.行内元素添加绝对定位或者固定定位，可以直接设置宽高\n	2.块级元素添加绝对定位或者固定定位，如果不给宽高，默认大小是内容的大小\n	3.脱标的盒子不会触发外边距塌陷\n	4.浮动的元素不会压住下面标准流的文字\n	5.绝对定位和固定定位会压住下面标准流的所有内容\n## 网页布局总结\n	1.标准流\n		可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局\n	2.浮动\n		可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局\n	3.定位\n		定位最大的特点就是有层叠的概念，就是让多个盒子前后叠压来显示，如果元素自由在某个盒子内移动就用定位布局 \n## 元素显示与隐藏\n	1.display:block/none 隐藏元素后，不在占有原来的位置\n	2.visibility:visible/hidden 隐藏元素后，继续占有原来的位置\n	3.overflow:visible/hidden 溢出隐藏', '2021-06-12 21:02:39', 31, 0, '167', 'H5基础', NULL, 'CSS', NULL, NULL, 0, '', 5, 0, 0);
INSERT INTO `article` VALUES (179, '复习阶段第二天', '复习阶段第二天', '2021-06-13 11:13:12', 31, 0, '166', '复习', NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);
INSERT INTO `article` VALUES (180, 'CSS高级', '## 精灵图技术\n	为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了CSS精灵图技术(也成CSS Sprites、CSS雪碧)\n	核心原理：将网页中的一些小背景图像整合到一张大图中，这样服务器只需一次请求就可以了，通过background-position来改变背景图位置\n## 字体图标 [阿里图标库](http://www.iconfont.cn/)\n	1.轻量级：一个图标字体要比一系列图像小，一旦字体加载了，图标就马上渲染出来，减少服务器请求\n	2.灵活性：本质就是文字，可以随意更改颜色，大小，产生阴影、透明效果、旋转等\n	3.兼容性: 几乎支持所有浏览器\n		注意：字体图标不能替代精灵图技术，只是对工作中图标部分技术的提升和优化\n## CSS三角\n	设置一个宽高为0的盒子，给它一个一定像素的边框，只保留一边边框的颜色，其余三边设为透明色transparent，就形成了一个小三角形\n## CSS用户界面样式\n	1.鼠标样式cursor\n	2.轮廓线outline\n	3.防止拖拽文本域resize\n## 图片、表单元素和文字对齐\n	图片、表单都属于行内块元素，默认的vertical-align是基线对齐，此时可以给图片、表单这些行内块元素的vertical-align属性设置middle，就可以让文字和图片垂直居中对齐了\n	问题：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐\n	主要解决方法有两种：\n			1.给图片添加vertical-align:middle/top/bottom;\n			2.将图片转为块级元素display:block;\n## 溢出的文字省略号显示\n#### 单行文本溢出显示省略号\n	1.先强制一行内显示文本\n	white-space: nowrap;(默认normal自动换行)\n	2.超出部分隐藏\n	overflow:hidden;\n	3.文字用省略号替代超出的部分\n	text-overflow:ellipsis;\n#### 多行文本溢出显示省略号，有兼容性问题\n```css\noverflow: hidden;\ntext-overflow: ellipsis;\n/* 弹性伸缩盒子模型显示*/\ndisplay: -webkit-box;\n/* 限制在一个块元素显示的文本的行数*/\n-webkit-line-clamp: 2;\n/*设置或检索伸缩盒对象的子元素的排列方式*/\n-webkit-box-orient: vertical;\n\n```	\n## 常见布局技巧\n#### margin负值运用\n	1. 让每个盒子margin往左侧移动-1px正好压住相邻盒子边框\n	2. 鼠标经过某个盒子时，提高当前盒子层级(如果没有定位，则加相对定位保留位置)\n#### 文字围绕浮动元素\n#### css三角运用\n#### css初始化\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2021-06-13 11:38:28', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 5, 0, 0);
INSERT INTO `article` VALUES (181, 'HTML5CSS3提高', '## HTML5新特性\n#### 语义化标签：利于seo搜索引擎\n	header、nav、article、section、aside、footer\n#### 多媒体标签\n	audio、video(谷歌浏览器需要添加muted来解决自动播放问题)\n#### input类型\n	type=\"search\"、type=\"email\"、type=\"date\"、type=\"number\"...\n#### 表单属性\n	required、placeholder、autofocus、autocomplete、multiple\n	通过input::placeholder{color: pink}; 修改提示文本颜色\n## CSS3新特性\n#### 属性选择器\n	1. input[value]\n	2. input[type=\'text\']\n	3. div[class^=\'icon\']\n	4. div[class$=\'icon\']\n#### 结构伪类选择器\n	1. ul li:first-child\n	2. ul li:last-child\n	3. ul li:nth-child(n)\n	4. ul li:nth-of-type(n)\n	小结：\n	结构伪类选择器一般用于选择父级里面的第个孩子\n	nth-child对于父元素里面所有孩子排序选择(序号是固定的)，先找到第n个孩子，然后看看是否和E匹配\n	nth-of-type对元素里面指定子元素进行排序选择，先去匹配E，然后根据E找第n个孩子\n#### 伪元素选择器\n	1. ::after  在元素内部的前面插入内容\n	2. ::before 在元素内部的后面插入内容\n	注意：\n	before和after创建一个元素，但是属于行内元素\n	新创建的这个元素在文档树中是找不到的，所以称为伪元素\n	必须有content属性\n#### CSS3盒子模型\n	1.box-sizing:content-box 盒子大小为width+padding+border(默认)\n	2.box-sizing:border-box 盒子大小为width\n#### CSS3过渡\n	经常和:hover一起使用\n	transition: 变化属性 花费时间 运动曲线 何时开始\n	常用写法 transition: all 0.5s;\n#### 2D转换\n	1. 位移  transform: translate(x,y);\n		 transform: translateX(n);\n		 transform: translateY(n);\n	2. 旋转  transform: rotate(度数deg);\n		 transform-origin: x y; 设置元素旋转中心点,默认50% 50%相当于center center\n	3. 缩放  transform: scale(x,y);\n		与直接修改宽高相比的优势：\n			不会影响其他的盒子，而且可以设置缩放的中心点\n   	4. 同时使用多个转换，其格式为 transform: translate() rotate() scale()\n	   	注意：1.其顺序会影响转换的效果(先旋转会改变坐标轴方向)\n		     2.当我们同时有位移和其他属性的时候，记得要将位移放在最前\n#### 子元素如何在父元素中居中\n	1.子元素相对于父元素绝对定位，子元素top，left设置50%，子元素margin-top和margin-left减去各自宽高的一半\n	2.子元素相对于父元素绝对定位，子元素上下左右全为0，然后设置子元素margin:auto\n	3.父元素设置display:table-cell; vertical-align:middle; 然后子元素设置margin:auto\n	4.子元素绝对定位，子元素top,left值为50%，transform:translate(-50%,-50%)\n	5.父元素设置弹性盒子，display:flex; justify-content:center;align-item:center;\n#### 动画\n	1.定义动画\n		@keyframes 动画名 {\n			0%{}\n			100%{}\n		}\n		等价 \n		@keyframes 动画名 {\n			from{}\n			to{}\n		}\n	2.调用动画\n		animation-name: 动画名;\n		animation-duration: 持续时间(s);\n		animation-iteration-count: 重复次数(infinite:无限次数)\n		简写形式：\n		animation: 动画名称 持续时间 运动曲线 何时开始 重复次数 结束状态\n#### 3D转换\n	1.移动 transform: translate3d(x,y,z);\n	       transform: translateZ(n);\n	2.透视 perspective\n		透视写到被观察元素的父级上，透视越小，被观察元素越大\n	3.旋转 \n	       transform: rotateX(度数deg);\n	       transform: rotateY(度数deg);\n	       transform: rotateZ(度数deg);	\n	4.3D呈现transform-style\n		写给父级，控制子元素是否开启三维立体空间\n		transform-style: preserve-3d;\n#### 私有前缀\n	1. -moz-：代表firefox浏览器私有属性\n	2. -ms-：代表ie浏览器私有属性\n	3. -webkit-：代表safari、chrome浏览器私有属性\n	4. -o-：代表Opera私有属性', '2021-06-13 14:34:34', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 5, 0, 0);
INSERT INTO `article` VALUES (182, 'PC端网页开发', '## favicon图标制作 [比特虫网站](http://www.bitbug.net/)\n	<link rel=\"shortcut icon\" href=\"favicon.ico\" />	\n## 网站TDK三大标签SEO优化\n	SEO的目的是对网站进行深度的优化，从而帮助网站获取免费的流量，进而在搜索引擎上提升网站的排名，提高网站知名度\n	1.title 网站标题 建议：网站名(产品名)-网站介绍\n	2.description 网站说明\n	3.Keywords 关键字	\n## logo SEO优化\n	1.logo里面首先放一个h1标签，目的是为了提权，告诉搜索引擎，这个地方很重要\n	2.h1里面再放一个链接，可以返回首页，把logo的背景图片给链接即可\n	3.为了搜索引擎收录我们，我们链接里面要放文字，但是文字隐藏\n	4.给链接一个title属性，这样鼠标放到logo上可以看到提示文字', '2021-06-13 14:45:48', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (183, '移动端开发', '## 视口\n	视口就是浏览器显示页面内容的屏幕区域，视口分为布局视口、视觉视口和理想视口\n	meta视口标签\n	<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n## 多倍图\n	在标准的viewport设备中，使用倍图来提高图片质量，解决在高清设备中的模糊问题\n## 初始化css  \n[normalize.css](https://necolas.github.io/normalize.css/8.0.1/normalize.css)\n## 移动端技术选型\n	1.单独制作移动端页面(主流)\n		1.流式布局(百分比布局)\n		2.flex弹性布局\n		3.less+rem+媒体查询布局\n		4.混合布局\n	2.响应式页面兼容移动端(其次)\n		1.媒体查询\n		2.bootstarp\n#### flex弹性布局\n	原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式\n	1.常见父项属性\n		1.flex-direction：设置主轴方向\n			row/column\n		2.justify-content：设置主轴上的子元素排列方式\n			flex-start/flex-end/center/space-around/space-between\n		3.flex-wrap：设置子元素是否换行\n			wrap/nowrap\n		4.align-content：设置侧轴上的子元素的排列方式(多行)\n			flex-start/flex-end/center/space-around/space-between\n		5.align-items：设置侧轴上的子元素排列方式(单行)\n			flex-start/flex-end/center/stretch\n		6.flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap\n	2.常见子项属性\n		1.flex子项目占有份数\n		2.align-self控制子项自己在侧轴的排列方式\n		3.order属性定义子项的排列顺序(前后顺序)\n\n#### less+rem+媒体查询布局\n	1.em是继承当前元素字体大小，如果没有，则寻找父级元素\n	2.rem是继承根元素html字体大小\n	3.rem的优点就是可以通过可以修改html里面的文字大小来改变页面中元素的大小以达成整体控制的效果\n	4.CSS3新语法媒体查询\n		1.使用@media查询，可以针对不同的媒体类型定义不同的样式\n		2.@media可以针对不同的屏幕尺寸设置不同的样式\n		3.当你重置浏览器大小的过程中，页面也会根据浏览器的宽高重新渲染页面\n		4.语法\n			@media screen and (max-width: 800px){}\n		5.引入资源\n			<link media=\"screen and (min-width: 320px)\">\n	5.常见的CSS预处理器：Sass、Less、Stylus\n		在CSS语法基础上，引入了变量，Mixin(混入)，运算以及函数等功能\n		一句话：Less是一门CSS预处理器，它扩展了CSS的动态特性\n		1.Less变量 @变量名:值;\n	6.rem适配方案\n		1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备\n		2.使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位\n		3.flexible.js+rem\n			flexible把屏幕划分为10等份\n#### 慕客团队协作 [链接](https://app.mockplus.cn/team/mqdtjrncsg)\n#### 响应式开发 [bootstrap链接](http://bootstrap.css88.com)\n	1. 原理就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的\n	2. bootstrap  \n	3. 解决ie678低版本兼容性问题，条件注释\n		<!--[if lt IE 9]>\n		  <script src=\"https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js\"></script>\n		  <script src=\"https://oss.maxcdn.com/respond/1.4.2/respond.min.js\"></script>\n		<![endif]-->\n	4. bootstrap布局容器  .container \n	5. 栅格系统 把布局容器12等份\n#### vw/vh\n	1. vw 视口宽度 1vw = 1/100视口宽度 \n	2. vh 视口高度 1vh = 1/100视口高度\n	3. vw/vh和百分比的区别\n		1. 百分比是相对于父元素来说的\n		2. vw/vh是相对于当前视口来说的\n	\n		\n		\n', '2021-06-13 22:53:21', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (184, '复习第三天', '复习第三天', '2021-06-14 09:56:01', 31, 0, '166', '复习', NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);
INSERT INTO `article` VALUES (185, 'JS基础', '## 浏览器执行JS过程\n	浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎来执行Js代码，JS引擎执行代码时逐行解释每一句源码转换为机器语言，然后计算机去执行，所以JavaScript语言称为脚本语言，会逐行解释执行。\n## JS组成\n	ECMAScript、DOM、BOM\n## 输入输出语句(归属浏览器)\n	1. prompt(\'\')   用户输入\n	2. alert(\'\')   弹出警示框\n	3. console.log(\'\')   控制台打印\n## 变量命名规范\n	1. 由字母、数字、_、$组成\n	2. 区分大小写\n	3. 不能以数字开头\n	4. 不能是关键字，如for、of、var等\n	5. 驼峰命名法\n	6. 变量保存在内存中，在内存中开辟空间，用于存储数据\n## 数据类型\n#### 简单数据类型\n	Number      通过isNAN()判断一个变量是否为非数字\n	Boolean\n	String	    \\n \\t 转义字符\n	Undefined   和数字相加返回NaN\n	Null        和数字相加返回数字本身\n	Symbol\n#### 复杂数据类型\n	Object\n	Array\n	function\n#### 检测变量数据类型\n	typeof\n#### 数据类型转换\n	1.转换为字符串\n		1.toString() 数字转字符串\n		2.String() 强制转换\n		3.拼接字符串(隐式转换，重点)\n	2.转换为数字型\n		1.parseInt(string)\n		2.parseFloat(string)\n		3.Number() 强制转换\n		4.js隐式转换(- * /) 利用算术运算符转换\n	3.转换为布尔型\n		1.Boolean()\n## 运算符\n#### 前置递增运算符 ++num  先自加，后运算\n#### 后置递增运算符 num++  先返回原值，后自加\n## 循环\n#### 九九乘法表\n```js\n	var result = \'\';\n        for (var i = 1; i <= 9; i++) {\n            for (var j = 1; j <= i; j++) {\n                result += j + \'*\' + i + \'=\' + j * i + \'\\t\';\n            }\n            result += \'\\n\';\n        }\n        console.log(result);\n```\n#### continue和break\n	1. continue是跳过当前次循环，继续执行其余次数的循环\n	2. break是退出整个循环，其余次数循环也不执行了\n	3. break也可以用在switch语句中表示退出整个语句\n## 数组\n#### 创建数组的方式\n	1.var 数组名 = new Array();\n	2.数组字面量[]\n#### 求数组最大值\n```js\n	var arr = [2, 6, 11, 98, 7, 65, 23];\n        var max = arr[1];\n        var min = arr[1];\n        for (var i = 0; i < arr.length; i++) {\n	    max = arr[i] > max ? arr[i] : max\n	    min = arr[i] < min ? arr[i] : min \n            /*if (arr[i] > max) {\n                max = arr[i];\n            }\n            if (arr[i] < min) {\n                min = arr[i];\n            }*/\n        }\n        console.log(max);\n        console.log(min);\n```\n#### 新增数组元素\n	1.修改length数组长度，新增的元素为undefined\n	2.通过修改索引号，追加数组元素\n	3.不要直接给数组名赋值，否则会覆盖掉以前的数据\n#### 冒泡排序\n	是一种算法，把一系列数据按照一定的顺序进行排列显示(从小到大或从大到小)\n```js\n	var temp = 0;\n        var arr = [1, 3, 2, 5, 4];\n        for (var i = 0; i < arr.length - 1; i++) {\n            for (var j = 0; j < arr.length - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        console.log(arr);\n```\n## 函数\n	1.作用：函数就是封装了一段可以被重复执行调用的代码块，目的就是让大量代码重复使用\n	2.声明函数\n		1.命名函数\n		function 函数名() {\n		\n		}\n		2.函数表达式(匿名函数)\n		var 变量名 = function() {\n		\n		}\n		\n	3.形参:形式上的参数，声明函数时用于接收实参的\n	4.实参:函数调用时传递的参数，实际上的参数\n	5.形参与实参个数不匹配\n		1.实参个数多于形参个数，则取到形参个数\n		2.实参个数少于形参个数，则多的形参会定义为undefined，两个参数运算最终得到的结果是NaN\n	6.函数如果没有return，则返回undefined\n	7.return不仅可以退出循环，还可以结束当前函数\n	8.arguments是函数的内置对象，存储了所有传递过来的实参，是一个伪数组\n	9.伪数组具有length属性，可以遍历，但是没有真正数组的一些方法pop、push等\n	10.利用函数求任意个数的最大值\n```js\nfunction getMax() {\n    var max = arguments[0]\n    for(var i = 1; i < arguments.length; i++) {\n        if(arguments[i] > max) {\n            max = arguments[i]\n        }\n    }\n    return max\n}\nconsole.log(1,6,9,25,35,20)\n```\n	11.函数封装冒泡排序\n```js\n	function sort(arr) {\n            for (var i = 0; i < arr.length - 1; i++) {\n                for (var j = 0; j < arr.length - i - 1; j++) {\n                    if (arr[j] > arr[j + 1]) {\n                        var temp = arr[j];\n                        arr[j] = arr[j + 1];\n                        arr[j + 1] = temp;\n                    }\n                }\n            }\n            return arr;\n        }\n\n        var arr1 = sort([1, 2, 9, 3, 4]);\n        console.log(arr1);\n        var arr2 = sort([5, 4, 3, 2, 1]);\n        console.log(arr2);\n```\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 作用域\n#### 定义\n	就是代码名字(变量)在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突\n#### 全局作用域与局部作用域(es6之前)\n	1.全局作用域：整个script标签或一个js文件中\n	2.局部作用域：函数内部\n#### 全局变量与局部变量(es6之前)\n	1.全局变量：整个script标签或一个js文件中，在函数内部没有声明直接使用的变量也是全局变量，只有浏览器关闭的时候才会销毁，比较占用内存资源，\n	2.局部变量：在函数内部，函数声明时的形参也是局部变量，当我们程序执行完毕就会销毁，比较节约内存资源\n#### es6之后新增块级作用域，在{}中就是块级作用域\n#### 作用域链\n	根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称为作用域链\n## 预解析\n	1.js引擎会把js代码里面所有的var 还有function提升到当前作用域的最前面\n	2.预解析分为变量预解析(变量提升)和函数预解析(函数提升)\n		1.变量提升：就是把所有的变量声明提升到当前作用域的最前面，不提升赋值操作\n		2.函数提升：就是把所有的函数声明提升到当前作用域的最前面，不调用函数\n		3.使用函数表达式，调用必须写在函数表达式的下面\n	3.预解析面试题\n```js\nf1();\nconsole.log(c)  //9\nconsole.log(b)  //9\nconsole.log(a)  //报错 a is not defined\nfunction f1() {\n    var a = b = c = 9\n    console.log(c)  //9\n    console.log(b)  //9\n    console.log(a)  //9\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 对象\n#### 创建对象\n	1.利用字面量创建对象{}  键值对形式  属性名: 属性值\n	2.利用new Object创建对象\n	3.利用构造函数创建对象(对象实例化)\n#### 使用对象\n	1. obj.属性名\n	2. obj[\'属性名\']\n#### 变量、属性、函数、方法总结\n	1.变量和属性的相同点：都是用来存储数据的\n	2.变量单独声明并赋值，使用的时候直接写变量名 单独存在\n	3.属性是在对象中的不需要声明的，使用的时候需要  对象.属性或者对象[\'属性\']\n	4.函数和方法的相同点：都是实现某种功能\n	5.函数时单独声明并调用的 函数名() 单独存在\n	6.方法在对象里面，调用的时候  对象.方法()\n#### 构造函数\n	构造函数：是一种特殊的函数，主要用来初始化对象，我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数中\n			function 构造函数名() {\n				this.属性 = 值;\n				this.方法 = function() {}\n			}\n			使用(实例化): new 构造函数名()\n			new关键字的执行过程\n				1.new之后在内存中创建了一个空对象\n				2.this就会指向这个新创建的空对象\n				3.执行构造函数中的代码，给这个空对象添加属性和方法\n				4.返回这个对象(不需要return关键字)\n#### 遍历对象\n```js\n	for(var k in obj) {\n 	    //k就是对象的属性名\n	    //obj[k]就是对象的属性值\n   	}\n```\n#### Js中的对象分为3种\n	1.自定义对象\n	2.内置对象\n	3.浏览器对象\n#### 内置对象\n	js中提供了多个内置对象：Math、Date、Array、String等\n#### 查文档\n	1.MDN\n	2.W3C\n\n#### Math对象\n	不是构造函数，不需要new，直接使用里面的属性和方法\n	1. Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值 \n	2. Math.floor(Math.random() * (max - min)) + min; //不含最大值，含最小值\n	3. Math.ceil() //向上取整\n	4. Math.round() //四舍五入\n	5. Math.random() //返回一个0到1的浮点数(包含0不包含1)\n#### Date对象\n	是构造函数，需要new来实例化\n	1.获取现在距离1970.1.1的总毫秒数(时间戳)\n		1.valueof()\n		2.getTime()\n		3.+new Date()\n		4.Date.now()\n	2.格式化日期\n```js\n	function getDate() {\n            var date = new Date();\n            var year = date.getFullYear();\n            var month = date.getMonth() + 1;\n            var dates = date.getDate();\n            var day = date.getDay();\n            var week = [\'星期日\', \'星期一\', \'星期二\', \'星期三\', \'星期四\', \'星期五\', \'星期六\'];\n\n            var h = date.getHours();\n            h = h < 10 ? \'0\' + h : h;\n            var m = date.getMinutes();\n            m = m < 10 ? \'0\' + m : m;\n            var s = date.getSeconds();\n            s = s < 10 ? \'0\' + s : s;\n            return year + \'年\' + month + \'月\' + dates + \'日 \' + h + \':\' + m + \':\' + s + \' \' + week[day];\n\n        }\n        console.log(getDate());\n```\n	3. 倒计时效果\n```js\n	function conutDown(time) {\n            var nowTime = +new Date(); //返回当前时间的时间戳\n            var inputTime = +new Date(time); //用户输入时间的时间戳\n            var times = (inputTime - nowTime) / 1000; //剩余时间的秒数\n\n            var d = parseInt(times / 60 / 60 / 24);\n            d = d < 10 ? \'0\' + d : d;\n            var h = parseInt(times / 60 / 60 % 24);\n            h = h < 10 ? \'0\' + h : h;\n            var m = parseInt(times / 60 % 60);\n            m = m < 10 ? \'0\' + m : m;\n            var s = parseInt(times % 60);\n            s = s < 10 ? \'0\' + s : s;\n            return d + \'天\' + h + \'时\' + m + \'分\' + s + \'秒\';\n        }\n        console.log(conutDown(\'2022-2-16 12:00:00\'));\n```\n#### Array对象\n##### 检测是否为数组\n	1.arr instanceof Array\n	2.Array.isArray(数组)  es6新增方法\n##### 方法API\n	1.push(元素) 在数组末尾添加一个或多个数组元素，返回新数组长度，改变原数组\n	2.unshift(元素) 在数组开头添加一个或多个数组元素，返回新数组长度，改变原数组\n	3.pop() 删除数组末尾的一个元素，返回删除的那个元素，改变原数组\n	4.shift() 删除数组开头的一个元素，返回删除的那个元素，改变原数组\n	5.reverse() 翻转数组\n	6.sort() 冒泡排序\n	sort方法有一个参数是回调函数，可以实现元素按某种规则排序\n			function(a,b) {\n			    return a - b; //升序\n			    //return b - a; //降序\n			}\n	7.indexOf(数组元素) 返回第一个满足条件数组元素的索引号 \n	8.lastIndexOf()\n	9.toString() \n	10.join(分隔符) 数组转换成字符串\n	11.concat() 连接两个或多个数组 返回新数组\n	12.slice(start,end) 数组截取 返回截取项目的新数组\n	13.splice(第几个开始,删除的个数) 返回被删除项目的新数组，注意这个会影响原数组 \n##### 数组去重案例\n	原理：我们遍历旧数组，然后拿着旧数组元素去查询新数组，如果该元素在新数组里面没有出现过，我们就添加，否则不添加,\n	     利用新数组.indexOf() 如果返回-1，说明新数组中没有该元素\n```JS\n	function unique(arr) {\n	    var newArr = [];\n	    for (var i = 0; i < arr.length; i++) {\n	        if (newArr.indexOf(arr[i]) === -1) {									 \n   		    newArr.push(arr[i]);\n	        }\n	    }\n	    return newArr;\n	}\n```\n##### 统计数组 arr 中值等于 item 的元素出现的次数\n	1.创建一个变量count统计元素数量，用forEach()遍历数组，用if语句判断每一个数组元素与item是否相等，相等则count+1。\n			function count(arr, item) {\n				var count = 0;\n				arr.forEach((elem)=>{\n					if(item === elem){\n					    count++;\n					}\n				});\n				return count;\n			}\n\n			function count(arr, item) {\n				var count = 0;\n				arr.forEach((e)=> item === e ? count++:0);\n				return count;\n			}\n	2.利用reduce()方法，用prev参数统计元素出现的次数，结合三元条件运算符来判断计数。\n			function count(arr, item) {\n				return arr.reduce((prev,curr)=> curr === item ? prev+1 : prev, 0);\n			}\n	3.利用filter()方法，通过判断数组的元素与item是否相等，返回相等的元素（返回的是相等的元素组成的数组），返回的数组的长度就是元素在数组中出现的次数。\n			function count(arr, item) {\n				return arr.filter((e)=>e===item).length;\n			}\n#### 字符串对象\n	1.基本包装类型\n		为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型:String、Number、Boolean\n		基本包装类型就是把简单数据类型包装成复杂数据类型，这样基本数据类型就有了属性和方法\n	2.字符串是不可变的，所以要避免大量拼接字符串\n	3.字符串的所有方法都不会修改字符串本身，操作完成会返回新的字符串\n		1.indexOf(\'要查找的字符\',[起始位置])\n	4.统计字符串中某个字符出现的位置和次数\n		原理：先查找第一个出现的位置，只要indexOf返回的结果不是-1，就继续往后查找\n		因为indexOf只能查找到第一个，所以后面的查找，利用第二个参数，当前索引号加1，从而继续查找\n```js\n	function getNum(str, str1) {\n            var index = str.indexOf(str1);\n            var num = 0;\n            while (true) {\n                if (index === -1) break;\n                num++;\n                console.log(\'第\' + num + \'次出现\' + str1 + \'的位置是:\' + index);\n                index = str.indexOf(str1, index + 1);\n            }\n            return num;\n        }\n        var str1 = \'o\';\n        var num = getNum(\'oabcdoefoxyzosdo\', str1);\n        console.log(str1 + \'总共出现的次数是:\' + num);\n```\n	5.方法 \n		1.charAt(index)\n		2.charCodeAt(index) 返回相应索引号的字符ASCII值  目的：判断用户按下了哪个键\n		3.str[index] H5新增方法\n		4.concat() 拼接字符串 等效于+\n		5.substr(start,length)\n		6.slice(start,end) end取不到\n		7.substring(start,end) end取不到，不接受负值\n		8.replace() 只会替换第一个符合条件的字符\n		9.split(\'分隔符\') 字符串转换为数组\n		\n	6.判断一个字符串中出现次数最多的字符，并统计次数\n		算法：1.利用charAt() 遍历这个字符串\n		      2.把每个字符都存储给对象，如果对象没有该属性，就存1，如果存在了就+1\n		      3.遍历对象，得到最大值和字符\n```js\n  	//得到字符串中每个字符出现次数的对象\n        function getObj(str) {\n            var o = {};\n            for (var i = 0; i < str.length; i++) {\n                var chars = str.charAt(i);\n                if (o[chars]) {\n                    o[chars] += 1;\n                } else {\n                    o[chars] = 1;\n                }\n            }\n            return o;\n        }\n        var str = \'abczoefoxyozzzopp\';\n        var obj = getObj(str);\n        console.log(obj);\n        //遍历对象\n        var max = 0;\n        var ch = [];\n        for (var key in obj) {\n            if (obj[key] > max) {\n                max = obj[key];\n                //ch.push(key);\n            }\n        }\n        for (var key in obj) {\n            if (parseInt(obj[key]) === max) {\n                ch.push(key);\n            }\n        }\n        console.log(ch, max);\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 堆和栈\n	1. 栈：存放函数的参数值，局部变量的值等，简单数据类型存放在栈中\n	2. 堆：存储复杂类型，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收\n	3. 简单数据类型存放在栈里面，存放的是值\n	4. 复杂数据类型首先在栈中存放地址，这个地址指向堆中的数据\n	5. 基本数据类型是值传递。\n	6. 复杂数据类型是引用传递.\n## API和Web API总结\n	1.API是为我们程序员提供的一个接口，帮助我们实现某种功能\n	2.Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果\n	3.Web API一般都有输入和输出(传递参数和返回值)\n\n', '2021-06-14 23:11:56', 31, 0, '168', 'js复习', NULL, NULL, NULL, NULL, 0, '', 6, 0, 0);
INSERT INTO `article` VALUES (186, '复习第四天', '复习第四天', '2021-06-15 10:14:11', 31, 0, '166', '复习', NULL, NULL, NULL, NULL, 1, NULL, 3, 0, 0);
INSERT INTO `article` VALUES (188, '有个想法', '经过观察，机动车停车，会占据位置，有时会影响交通，影响其他车子通行，\n初步想法：可不可以设计一个软件，机动车车主注册之后，在服务器上保存这个车主的相关信息，其他车主可以通过查询该车车牌号，从我们服务器调取相关信息，比如车主常用联系电话，根据相关权限，是否能让我们服务人员通知该车主进行车子移位', '2021-06-15 14:08:38', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);
INSERT INTO `article` VALUES (189, 'DOM', '## DOM 文档对象模型\n#### 获取元素 API\n	1.getElementById() 返回的是一个元素对象\n	2.getElemensByTagName() 返回元素对象的集合 伪数组形式\n	3.getElementsByClassName()\n	4.querySelector()\n	5.querySelectorAll()\n	6.document.body //返回body元素对象\n	7.document.documentElement //返回html元素对象\n#### 执行事件步骤\n	1.获取事件源\n	2.注册事件(绑定事件)\n	3.添加事件处理程序(采取函数赋值的形式)\n#### innerText和innerHTML的区别\n	1.innerText不识别html标签 去除空格和换行\n	2.innerHTML识别html标签 保留空格和换行\n#### 修改样式属性\n	element.style获取修改元素样式只有在样式比较少的时候使用，样式多的时候可以使用element.className修改样式\n#### 操作元素(可读写)\n	1.操作元素内容：innerText、innerHTML\n	2.操作常见元素属性：src、href、title、alt等\n	3.操作表单元素属性：type、value、disabled等\n	4.操作元素样式属性：element.style、className\n#### 排他思想\n	如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法：\n		1.所有元素全部清除样式(干掉其他人)\n		2.给当前元素设置样式(留下自己)\n		3.顺序不能颠倒.\n#### 获取元素属性值\n	1.element.属性\n	2.element.getAttribute(\'属性\')\n	3.区别\n		1.element.属性 获取内置属性值(元素本身自带的属性)\n		2.element.getAttribute(\'属性\') 主要获取自定义属性\n		3.自定义属性目的是为了保存并使用数据，有些数据可以保存到页面中而不用保存到数据库中\n		4.设置自定义属性 名字规则：以data-开头\n		5.H5新增了获取自定义属性的方法：element.dataset.属性名或者 element.dataset[\'属性名\']\n#### 节点操作\n	1.父节点 parentNode 亲爸爸\n	2.子节点 childNodes 所有的子节点包括元素节点和文本节点，\n		如果只想要获得里面的元素节点，需要使用nodeType判断，如果为1则是元素节点\n	3.获取子元素节点 children\n	4.兄弟节点 nextElementSibling 下一个元素节点\n	5.创建节点 createElement()\n	6.添加节点 node.appendChild(child)  		                                       \n              node.insertBefore(child,指定元素)\n	7.删除节点 node.removeChild(child)\n	8.复制节点 node.cloneNode() 浅拷贝，不复制内容，加个参数true则为深拷贝\n#### 三种动态创建元素区别\n	1.document.write() 如果文档流执行完毕，它会导致页面全部重绘\n	2.element.innerHTML 创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂\n	3.document.createElement()  创建多个元素效率稍微低一些，结构更加清晰\n#### 注册事件\n	1.传统注册方式\n		btn.onclick = function(){}\n		特点：注册事件的唯一性\n		     同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数会覆盖前面注册的处理函数\n	2.方法监听注册\n		addEventListener(type,listener,[,useCaputure])\n		同一个元素同一个事件可以设置多个处理函数\n#### 删除事件\n	1.传统方式\n		btn.onclick = null\n	2.方法监听方式\n		removeEventListener(type,listener,[,useCaputure])\n#### DOM事件流三个阶段\n	1.捕获阶段\n	2.当前目标阶段\n	3.冒泡阶段\n#### 事件对象\n	1.常见的属性和方法\n		e = e || window.event 兼容性写法\n		e.target 返回的是触发事件的对象(元素) this 返回的是绑定事件的对象(元素)\n		e.preventDefault() 阻止默认行为 如让链接不跳转或者让提交按钮不提交\n		e.stopPropagation() 阻止事件冒泡\n	2.事件委托(代理)\n		不是每个子节点单独设置事件监听器，而是把事件监听设置在其父节点上，然后利用冒泡原理影响设置每个子节点\n		案例：给ul注册点击事件，然后利用事件对象的target来找到当前点击的li，因为点击li，事件会冒泡到ul上\n		ul有注册事件，就触发事件监听器\n		作用：我们只操作了一次DOM，提高了程序的性能\n```js\nvar ul = document.querySelector(\'ul\')\nul.addEventListener(\'click\',function(e) {\n    this.children.forEach(item=>{\n	item.style.backgoundColor = \'\'\n    })\n    e.target.style.backgroundColor = \'pink\'\n})\n```\n	3.禁止浏览器右键菜单\n```js\ndocument.addEventListener(\'contextmenu\', function(e) {\n    e.preventDefault()\n})\n```\n	4.禁止选中文字\n```js\ndocument.addEventListener(\'selectstart\', function(e) {\n    e.preventDefault()\n})\n```\n\n#### 鼠标事件对象\n	1. clientX和clientY 鼠标在可视区的x和y坐标\n	2. pageX和pageY 鼠标相对于文档页面的x和y坐标\n	3. screenX和screenY 鼠标相对于电脑屏幕的x和y坐标 \n#### 常见的键盘事件\n	1. keyup     键盘松开\n	2. keydown   键盘按下 返回ASCII值时不区分字母大小写\n	3. keypress  键盘按下 不识别功能键，如ctrl、shift、箭头等\n	4. 执行顺序keydown>keypress>keyup\n#### 键盘事件对象\n	1. keycode 返回相应键的ASCII值\n\n\n\n		', '2021-06-15 21:40:19', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (190, 'BOM', '## BOM 浏览器对象模型  window是BOM的顶级对象\n#### 页面加载事件\n	1.load 等页面内容全部加载完成，包含页面dom元素、图片、flash、css等\n	2.DOMContentLoaded 是dom加载完毕，不包含图片、flash、css等就可以执行，加载速度更快,如果页面图片等太多，考虑到用户体验，使用DOMContentLoaded较好\n#### 定时器\n	1.setTimeout(调用函数,延时时间) 只调用一次\n	2.setInterval(调用函数,时间间隔) 会重复调用函数\n#### this\n	1.全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window)\n	2.方法调用中谁调用this指向谁\n	3.构造函数中this指向构造函数的实例\n#### js执行机制\n	js会把所有的任务分为同步任务和异步任务，\n	同步任务都在主线程上执行，形成一个执行栈，把回调函数当成异步任务来执行，放到任务队列中\n	1.先执行执行栈中的同步任务\n	2.异步任务(回调函数)放入任务队列中\n	3.一旦执行栈中的同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是读取到的异步任务放到执行栈开始执行\n	4.主线程不断的重复获取任务，执行任务，再获取任务，再执行，这种机制就称为事件循环(event loop)\n#### location对象\n	1. location.href 返回整个浏览器地址\n	2. location.search 返回带?的参数	\n	3. location.assign(url) 跳转页面，记录浏览历史，可以后退\n	4. location.replace(url) 不记录浏览历史\n	5. location.reload() 刷新页面，如果有true参数代表强制刷新\n#### navigator对象\n	1. userAgent 返回由客户机发送服务器的user-agent头部的值\n#### history对象\n	1. forward()\n	2. back()\n	3. go(1)\n\n\n	', '2021-06-15 23:19:35', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (191, '复习阶段第五天', '复习阶段第五天', '2021-06-16 11:50:10', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);
INSERT INTO `article` VALUES (192, '网页特效', '## offset系列\n#### offsetTop和offsetLeft 得到元素的偏移量，不带单位的数值\n	以带有定位的父亲为准，如果没有父亲或者父亲没有定位则以body为准\n#### offsetWidth和offsetHeight 得到元素大小，包含padding+border+width\n#### offsetParent 返回带有定位的父级，如果没有则返回body\n#### offset和style区别\n	1.offset可以得到任意样式表中的样式值，style只能得到行内样式表中的样式值\n	2.offset获得的数值是没有单位的，style得到的是带有单位的字符串\n	3.offsetWidth包含padding+border+width，style.width获得不包含padding和border的值\n	4.offsetWidth等属性是只读属性，不能赋值，style.width是可读写属性\n## client系列\n#### clientWidth不包含边框，包含padding\n#### pageshow 重新加载页面时触发的事件\n	和load相比，解决火狐浏览器往返缓存的问题，通过e.persisted\n	就是说pageshow事件不管是否有缓存都会触发\n## scroll系列\n#### scrollWidth 返回自身实际内容大小，包含滚动条之外的内容\n#### scrollTop 返回滚动距离，就是元素滚动后被卷去的部分\n#### window.pageYOffset  页面被卷去的头部\n## 立即执行函数\n	(function() {})() 或者 (function(){}())\n	主要作用：创建一个独立的作用域，避免了命名冲突问题\n## mouseenter和mouseover的区别\n	mouseenter不会冒泡，只会在经过自身盒子时触发\n	mouseover会冒泡\n## JS动画\n#### 核心原理：通过定时器setInterval()不断移动盒子位置\n#### 简单封装函数动画\n```js\n	//obj目标对象， target目标位置\n	function animate(obj, target, time, callback) {\n            \n            //当我们不断点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器\n            //解决方案就是让元素只有一个定时器执行\n            clearInterval(obj.timer);\n	    //给不同元素指定不同定时器，减少消耗内存空间\n            obj.timer = setInterval(function() {\n                //缓动动画：(目标值 - 现在位置) / 10 作为每次移动的距离 步长\n                //var step = Math.ceil((target - obj.offsetLeft) / 20);\n                var step = (target - obj.offsetLeft) / 20;\n                step = step > 0 ? Math.ceil(step) : Math.floor(step);\n                if (obj.offsetLeft == target) {\n                    clearInterval(obj.timer);\n                    //回调函数写到定时器结束之后\n                    //if (callback) {\n                    //    callback();\n                    //}\n		    callback && callback()\n                }\n                obj.style.left = obj.offsetLeft + step + \'px\';\n            }, time);\n        }\n```\n## 常见网页特效\n#### 轮播图\n	节流阀:目的是当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发\n	核心思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数\n#### 返回顶部\n	window.scroll(x,y) 让窗口滚动到某个位置\n\n## 移动端网页特效\n#### touch触摸事件\n	1. touchstart\n	2. touchmove\n	3. touchend\n#### 触摸事件对象\n	1. touches 正在触摸屏幕的手指列表\n	2. targetTouches 正在触摸当前DOM的手指列表(常用)\n		1. 拖动元素使用到targetTouches[0] 里面的pageX和pageY\n		   原理：盒子原来位置+手指移动距离\n		2. 手指移动也会触发滚动屏幕，可以通过e.preventDefault()阻止默认的滚动行为\n	3. changedTouches 手指状态发生改变的列表 从有到无、从无到有\n#### classList属性 返回元素类名的集合  伪数组\n	1.add() 追加类名\n	2.remove() 删除类名\n	3.toggle() 切换类\n\n\n', '2021-06-16 16:47:18', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 1, 0, 0);
INSERT INTO `article` VALUES (193, 'JS本地存储', '## 特性\n	1. 数据存储在用户浏览器\n	2. 设置、读取方便，刷新页面不会丢失数据\n	3. 容量较大，sessionStorage约5M、localStorage约20M\n	4. 只能存储字符串，可以将对象JSON.stringify()转成字符串后存储\n## sessionStorage\n	1.生命周期为关闭浏览器窗口\n	2.在同一个窗口(页面)下数据可以共享\n	3.以键值对的形式存储\n	4.setItem(key,value)\n	5.getItem(key)\n	6.removeItem(key)\n	7.clear()\n## localStorage\n	1.生命周期永久有效，除非手动删除，否则关闭页面也存在\n	2.可以多窗口(页面)共享(同一浏览器可以共享)\n	3.以键值对的形式存储', '2021-06-16 16:53:38', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (194, 'JQuery笔记', '## 入口函数\n	$(function(){}) 页面dom对象加载后执行  相当原生js的load函数\n	要使用jquery提供的函数，需要将js对象转为jQuery对象  $(dom对象)\n## jQuery对象\n	jQuery对象是一个数组，数组成员是dom对象，可以使用[下标]或get(下标)获取dom对象\n## 隐式迭代\n	遍历匹配的所有DOM元素(伪数组形式存储)\n## 筛选选择器\n	1. $(\'li:first\')\n	2. $(\'li:last\')\n	3. $(\'li:eq(2)\')\n	4. $(\'li:odd\')\n	5. $(\'li:even\')\n## 筛选方法\n	1. parent()\n	2. children(\'li\')\n	3. find(\'li\')\n	4. eq(index)\n	5. siblings()\n## Jquery插件\n[JQuery插件库](http://www.jq22.com/)\n[JQuery之家](http://www.htmleaf.com/)\n\n', '2021-06-16 18:13:50', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 2, 0, 0);
INSERT INTO `article` VALUES (196, 'git复习', '## git工作区域\n	1. git仓库\n	2. 暂存区\n	3. 工作区\n## git添加文件流程\n	1. git status\n	2. git add\n	3. git commit -m \"提交描述\"\n	4. git status\n## git初始化\n#### 基本信息设置\n	1. 设置用户名\n	git config --global user.name \'用户名\'\n	2. 设置邮箱\n	git config --global user.email \'邮箱\'\n#### 初始化\n	1. git init\n#### git远程仓库\n	作用：备份，实现代码共享集中化管理\n	git push 提交到远程仓库\n#### git克隆\n	git clone 仓库地址\n## 个人站点\n#### 访问\n	https:用户名.github.io\n\n	\n\n\n## 查看历史记录信息\n	1. git log 查看完整历史记录信息\n		多屏显示控制方式：\n		空格 向下翻页\n		b 向上翻页\n		q 退出\n	2. git log --pretty=oneline 查看简洁历史\n	3. git log --oneline 查看更加简洁历史\n	4. git reflog  查看更加简洁历史并显示指针移动步数\n## git版本穿梭\n	1. git reset --hard 索引值  回到某个版本\n	2. git diff [文件名] 比较文件差异\n## 分支操作\n	1. git branch -v 查看分支\n	2. git branch [分支名] 创建分支\n	3. git checkout [分支名] 切换分支\n	4. get merge [新分支]\n## 拉取\n	1. pull = fetch + merge\n	2. git fetch [远程库地址别名] [远程分支名]\n	3. git merge [远程库地址别名/远程分支名]\n	4. git pull [远程库地址别名] [远程分支名]\n\n\n', '2021-06-17 11:52:15', 31, 0, '169', 'git', NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (200, '复习阶段第六天', '复习阶段第六天 nodejs', '2021-06-17 15:01:54', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 2, 0, 0);
INSERT INTO `article` VALUES (201, 'nodejs笔记', '## 搭建最简单的服务器\n```js\nconst http = require(\'http\')\nhttp.createServer((req, res) => {\n    //req获取url地址传过来的信息\n    console.log(req.url);\n    //设置响应头\n    res.writeHead(200, { \"Content-type\": \"text/html;charset=\'utf-8\'\" })\n    res.write(\'<head><meta charset=\"UTF-8\"></head>\') //解决中文乱码\n    res.write(\'你好，this is nodejs\');\n    //结束响应\n    res.end()\n}).listen(3001)\n```\n## url模块\n```js\nconst url = require(\'url\')\n//得到{ name: \'zhangsan\', age: \'20\' }形式的对象\nurl.parse(req.url, true).query \n```\n\n## 模块化\n	将公共的功能抽离成一个单独的js文件，通过exports或者module.exports 向外暴露属性或方法\n	使用的时候通过require方式引入这个模块\n## CommonJS规范的包目录\n	1. package.json 包描述文件\n	2. bin 用于存放可执行二进制文件的目录\n	3. lib 用于存放JavaScript代码的目录\n	4. doc 用于存放文档的目录\n## fs模块\n	1. fs.stat() 检测是文件还是目录\n	2. fs.mkdir() 创建目录\n	3. fs.writeFile() 创建并写入文件\n	4. fs.appendFile() 追加文件\n	5. fs.readFile() 读取文件\n	6. fs.readdir() 读取目录\n	7. fs.rename() 重命名\n	8. fs.rmdir() 删除目录\n	9. fs.unlink() 删除文件\n	10. fs.createReadStream() 创建读取流\n```js\nvar readStream = fs.createReadStream(\'\')\nreadStream.on(\'data\',(data)=>{})\nreadStream.on(\'end\',()=>{})\nreadStream.on(\'error\',(err)=>{})\n```\n	11. fs.createWriteStream(\'\') 写入流\n```js\nvar writeStream = fs.createWriteStream(\'\')\nwriteStream.write(str)\nwriteStream.end()  //标记写入完成\nwriteStream.on(\'finish\',()=>{\n    console.log(\'写入完成\')\n})\n```\n	12. 管道流  用于复制文件\n```js\nreadStream.pipe(writeStream)\n```\n\n## ejs模板引擎\n	将后台数据通过js渲染到前台静态页面上\n\n## nodejs操作mongoDB\n```js\n//1.引入mongodb中的MongoClient模块\nconst { MongoClient } = require(\'mongodb\');\n//2.定义数据库连接地址\nconst url = \'mongodb://127.0.0.1:27017\';\n//3.定义操作的数据库\nconst dbName = \'itying\';\n//4.实例化MongoClient 传入数据库连接地址\n//const client = new MongoClient(url, { useUnifiedTopology: true });\nMongoClient.connect(url,{ useUnifiedTopology: true },(err,client)=>{\n    //这种方式每次得到一个新的client对象，不会相互影响，每次关闭的都是当前的连接\n})\n//5.连接数据库\nclient.connect((err) => {\n    if (err) {\n        console.log(err);\n        return\n    }\n    console.log(\'数据库连接成功\');\n    //得到要操作的数据库\n    let db = client.db(dbName);\n    //1.查找数据\n    db.collection(\'user\').find({}).toArray((err, data) => {\n        console.log(data);\n        //最后,操作数据库完毕要关闭数据库连接\n        client.close()\n    });\n    //2.增加数据\n    db.collection(\'user\').insertOne({ \"username\": \"nodejs操作mongodb\", \"age\": 10 }, (err, result) => {\n        if (err) {\n            console.log(err);\n            return\n        }\n        console.log(\"增加成功\");\n        console.log(result);\n        client.close()\n    });\n    //3.修改数据\n    db.collection(\'user\').updateOne({ \"username\": \"zhangsan\" }, { $set: { \"age\": 10 } }, (err, result) => {\n        if (err) {\n            console.log(err);\n            return\n        }\n        console.log(\"修改成功\");\n        console.log(result);\n        client.close()\n    });\n    //4.删除一条数据\n    db.collection(\'user\').deleteOne({ \"username\": \"zhangsan\" }, (err) => {\n        if (err) {\n            console.log(err);\n            return\n        }\n        console.log(\"删除成功\");\n        client.close()\n    });\n    //4.删除多条数据\n    db.collection(\'user\').deleteMany({ \"username\": \"zhangsan\" }, (err) => {\n        if (err) {\n            console.log(err);\n            return\n        }\n        console.log(\"删除成功\");\n        client.close()\n    })\n})\n```\n	', '2021-06-17 19:11:07', 31, 0, '170', 'nodejs', NULL, NULL, NULL, NULL, 0, '', 5, 0, 0);
INSERT INTO `article` VALUES (202, 'MongoDb', '## 关系型数据库和非关系型数据库\n	1.表就是关系或者说表与表之间存在关系\n		所有关系型数据库都需要通过sql语言来操作\n		所有的关系型数据库在操作之前都需要设计表结构\n		而且数据表还支持约束\n			唯一的、主键、默认值、非空\n	2.非关系型数据库非常的灵活\n		有的非关系型数据库就是key-value键值对\n		但是mongoDB是长得最像关系型数据库的非关系型数据库\n			数据库  ==》 数据库\n			数据表  ==》 集合(数组)\n			表记录	==》 文档对象\n		mongoDB不需要设计表结构\n## 基本命令\n	1. show dbs：  查看显示所有数据库\n	2. db：   查看当前操作的数据库\n	3. use 数据库名称： 切换到指定的数据，如果没有会新建  \n	4. db.user.insert({\"name\":\"zhangsan\",\"age\":20}) 插入集合\n	5. show collections  查看集合\n	6. db.user.find()  查看集合全部记录(文档对象)\n	7. db.user.find({\'age\':20})  按条件查看集合记录(文档对象)\n	8. db.dropDatabase() 删除数据库\n	9. db.use1r.drop() 删除集合\n	10. db.admin.find().count() 集合数据条数\n	11. db.admin.find().skip(10).limit(10) 查询第二页 每页10条数据 可以用于分页 limit是pageSize  skip是(第几页-1)*pageSize\n	12. db.user.update({\"username\":\"zhangsan\"},{$set:{\"username\":\"张三\"}}) 修改数据\n	13. db.admin.remove({\"age\":{$gt:30}}) 删除数据\n	\n## 权限验证\n	1. db.createUser({\n	       user:\"admin\",\n	       pwd:\"123456\",\n	       roles:[{role:\"root\",db:\"admin\"}]     \n	   }) 创建超级管理员\n	2. mongo admin -u admin -p 123456  用超级管理员登录\n## aggregate 聚合管道\n	用于表的关联查询，数据统计\n	1. $project 筛选指定列\n	2. $match 筛选符合条件的数据\n	3. $group 分组统计\n	4. $sort 排序\n	5. $limit 查询几条\n	6. $skip 跳过几条\n	7. $lookup 表关联\n	db.order.aggregate([\n	    {\n		$lookup:{\n		    from:\"order_item\",\n		    localField:\"order_id\",\n		    foreignField:\"order_id\",\n		    as:\"items\"\n		}\n	    }   \n	])\n\n	 \n', '2021-06-17 22:19:53', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 1, 0, 0);
INSERT INTO `article` VALUES (203, '复习阶段第七天', '继续复习nodejs', '2021-06-18 09:49:13', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);
INSERT INTO `article` VALUES (204, 'Express复习', '## 动态路由\n```js\napp.get(\"/user/:id\",(req,res)=>{\n    var id = req.params[\"id\"]  //获取动态路由传过来的值\n})\n```\n## get传值\n```js\napp.get(\"/user\",(req,res)=>{\n    let query = req.query //获取get传值，?后面的键值对，json格式的对象\n})\n```\n\n## 托管静态资源\n```js\napp.use(express.static(path.join(__dirname, \'public\')));\n```\n\n## 中间件\n#### 应用级中间件：用于权限判断\n```js\napp.use((req,res,next)=>{\n    //权限判断操作\n    //通过则调用next函数	\n    next()\n})\n```\n#### 路由级中间件：用得少\n	匹配到当前路由之后继续匹配下一个路由(动态路由)\n#### 错误处理中间件\n```js\napp.use(function(err, req, res, next) {\n\n});\n```\n#### 内置中间件:可以配置静态资源\n```js\napp.use(express.static(path.join(__dirname, \'public\')));\n```\n#### 第三方中间件：用得最多,如cookieParser\n```js\nvar cookieParser = require(\'cookie-parser\');\napp.use(cookieParser());\n```\n## Express生成器', '2021-06-18 14:16:41', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 1, 0, 0);
INSERT INTO `article` VALUES (209, 'ES6-ES11', '## ES6\n#### let\n	1. 块级作用域\n	2. 不存在变量提升\n	3. 不影响作用域链\n#### const\n	1. 常量\n	2. 一定要赋初始值\n	3. 块级作用域\n	4. 值不能修改\n	5. 对于数组和对象的元素可以修改\n#### 变量解构赋值\n	1. 数组解构\n	const F4 = [\'aa\',\'bb\',\'cc\',\'dd\']\n	let [aa,bb,cc,dd] = F4\n	2. 对象解构\n	const zhao = {\n	    name: \'赵本山\',\n	    age: 20,\n	    xiaopin() {\n 		console.log(\'演小品\')\n	    }\n	}\n	let {name,age,xiaopin} = zhao\n#### 模板字符串\n	1. ``\n	2. 可以直接出现换行符\n	3. 变量拼接 ${}\n#### 简化对象写法\n	1. 对象中属性名和属性值一样可以省略属性名\n	2. 对象中的方法可以省略function\n#### 箭头函数\n	1. () => {}\n	2. this是静态的，this始终指向函数声明时所在的作用域下的this的值\n	3. 不能作为构造函数实例化对象\n	4. 不能使用arguments对象\n	5. 箭头函数适合与this无关的回调，定时器、数组的方法回调\n	6. 箭头函数不适合与this有关的回调，事件回调、对象的方法\n#### 函数参数赋初始值\n	1.形参初始值\n	function add(a,b,c=10){\n	    return a + b + c\n	}\n	2. 与解构赋值结合\n#### rest参数\n	1. 用于获取函数的实参，用来代替arguments\n	2. ...args\n	3. 必须放在最后一个参数\n#### 扩展运算符\n	1. 能将数组转换为逗号分隔的参数序列\n	2. 数组合并\n	const kuaizi = [\'王太利\',\'肖央\']\n	const fenghuang = [\'曾毅\',\'玲花\']\n	const zh = [...kuaizi ,...fenghuang ]\n	3. 数组克隆  浅拷贝\n	4. 将伪数组转为真正的数组\n#### Symbol\n	1. Symbol的值是唯一的，用来解决命名冲突问题\n	2. Symbol不能和其他数据进行运算\n	3. Symbol定义的对象属性不能使用for in循环，但是可以使用Reflect.ownKeys来获取对象的所有键名\n#### 迭代器 for of遍历\n	1. 原理：\n		1. 创建一个指针对象，指向当前数据结构的起始位置\n		2. 第一次调用对象next方法，指针自动指向数据结构的第一个成员\n		3. 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员\n		4. 每次调用next方法返回一个包含value和done属性的对象\n	2. 自定义遍历数据\n```js\n//声明一个对象\nconst banji = {\n    name: \'终极一班\',\n    stus: [\n	\'xiaoming\',\n	\'xiaoning\',\n	\'xiaotian\',\n	\'knight\'\n    ],\n    [Symbol.iterator]() {\n	//索引变量\n	let index = 0;\n	return {\n	    next = () => {\n 		if(index < this.stus.length){\n		    const result = { value: this.stus[index], done: false }\n		    index ++\n		    return result\n		}else {\n		    return { value: undefined, done: true}\n		}\n	    }\n	}\n    }\n}\n```\n\n#### 生成器\n	1. 一个特殊的函数，异步编程的解决方案\n```js\nfunction * gen() {\n    console.log(\'hello\')\n}\nlet iterator = gen()\niterator.next()\n```\n#### Promise\n	1. 异步编程的解决方案\n	2. 封装异步操作并返回其成功或失败的结果\n	3. 封装ajax请求\n```js\nconst p = new Promise((resolve,reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.open(\'get\',\'https://xxx\')\n    xhr.send()\n    xhr.onreadystatechange = function() {\n  	if(xhr.readyState === 4) {\n	    if(xhr.status >=200 && xhr.status < 300) {\n		resolve(xhr.response)\n	    }else{\n		reject(xhr.status)\n	    }\n	}\n    }\n})\n//指定回调\np.then(function(value){\n    console.log(value)\n},function(reason){\n    console.error(reason)\n})\n```\n#### Set\n	1. Set集合，类似于数组，但是成员是唯一的\n	2. size  返回集合的元素个数\n	3. add 增加新元素，返回当前集合\n	4. delete 删除元素，返回boolean\n	5. has 检测集合中是否包含某个元素，返回boolean\n	6. 可以传入一个数组当作参数\n	7. 数组去重\n	let arr = [1,2,3,4,5,4,3,2,1]\n	let result = [...new Set(arr)]\n\n#### Map\n	1. 类似于对象\n	2. 键的范围不限于字符串\n	3. size\n	4. set 增加新元素，返回当前map\n	5. get\n	6. has\n	7. clear\n#### class类\n	1. 构造函数语法糖\n	2. constructor 定义构造函数初始化\n	3. extends 继承父类\n	4. super 调用父级构造方法\n	5. static 定义静态方法和属性\n	6. 父类方法可以重写\n#### 数值扩展\n	1. Number.isNaN \n	2. Number.isInteger\n	3. Math.trunc 将数字的小数部分抹掉\n	4. Math.sign 判断一个数是正数、负数还是0 正数返回1，负数返回-1\n#### 对象方法扩展\n	1. Object.is 判断两个值是否完全相等\n	可以判断两个NaN相等返回true，如果两个NaN使用===判断返回false\n	2. Object.assign 对象合并，主要用于配置的合并\n	3. Object.setPrototypeOf、Object.getPrototypeOf 设置和获取原型对象\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 模块化\n	1. 防止命名冲突\n	2. 代码复用\n	3. 高维护性\n	4. ES6之前模块化规范有：CommonJS、AMD、CMD\n	5. ES6模块化主要通过两个命令来实现：export和import\n		1. 分别暴露 export let ...\n		2. 统一暴露 export {}\n		3. 默认暴露 export default {}\n		4. 通用引入 import * as ... from \'\'\n		5. 解构赋值 import {} from \'\'\n		6. 简便形式只针对默认暴露 import ... from \'\'\n	6. babel对ES6模块化代码转换\n## ES7\n	1. includes 用来检测数组中是否包含某个元素，返回boolean\n	2. 指数操作符 ** 相当于Math.pow()\n## ES8 \n#### async和await\n	1. async函数返回promise对象，结果由async函数执行的返回值决定\n	2. await必须写在async函数中\n	3. await右侧的表达式一般为promise对象\n	4. await返回promise成功的值\n	5. await的promise失败了，就会抛出异常，需要通过try...catch捕获\n#### ES8对象方法扩展\n	1. Object.values 返回对象属性值的数组\n	2. Object.entries 返回对象自身可遍历属性[key,value]的数组,可以用于创建map\n	3. Object.getOwnPropertyDescriptors 返回对象所有自身属性的描述对象\n## ES9\n#### ES9扩展运算符和rest参数\n	1. 在ES6中已经引入，不过是只针对数组\n	2. ES9中为对象提供了像数组一样的rest参数和扩展运算符\n#### 正则扩展-命名捕获分组\n#### 正则扩展-反向断言\n#### 正则扩展-dotAll模式\n## ES10\n#### ES10对象方法扩展\n	1. Object.fromEntries  创建对象，参数可以是二维数组、Map，与ES8中的Object.entries相反\n#### ES10字符串方法扩展\n	1. trimStart和trimEnd\n#### ES10数组方法扩展\n	1. flat 平，将多维数组转换为低维数组\n	2. flatMap 将Map返回的是多维数组转为低维数组\n#### Symbol.prototype.description\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## ES11\n#### 类的私有属性\n	1. #name\n	2. 只能在类内部操作\n#### Promise.allSettled\n	1. 接收promise对象的数组\n	2. 始终返回成功状态的promise\n	3. 成功的值是每个promise对象结果值，不管成功或失败\n#### 字符串批量匹配正则 matchAll\n#### 可选链操作符  ?.\n#### 动态import  用的时候再导入\n#### BigInt 大整形\n#### globalThis 全局this\n\n\n\n\n\n	\n\n\n\n\n\n\n\n	\n	\n\n\n\n\n\n\n', '2021-06-18 23:34:07', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 1, 0, 0);
INSERT INTO `article` VALUES (210, '复习阶段第八天', '# 今天开始复习vue', '2021-06-19 08:49:44', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);
INSERT INTO `article` VALUES (211, 'Vue基础', '## 创建Vue对象，声明式编程\n	new Vue({\n	    el: \'#app\', //挂载要管理的元素\n	    data: {\n		//定义数据，可以是自己定义的，也可以是网络请求过来的数据\n	    }\n	})\n	1.el属性：该属性决定了这个Vue对象挂载到哪个元素上\n	2.data属性：该属性存储一些数据(在组件中必须是函数)\n	3.methods：定义方法\n## Vue中的MVVM\n	1. 视图模型层也就是ViewModel，是view和model沟通的桥梁\n	2. 一方面实现了Data Binding，也就是数据绑定，将model的改变实时绑定到view中\n	3. 另一方面实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动)时，能监听到并在需要的情况下改变对应的data\n	4. 在Vue中new Vue({})就是ViewModel，data就是model，Dom就是view\n## 生命周期\n	1. 当我们使用new Vue创建一个vue实例的时候，里面会执行一系列的生命周期函数(钩子函数)，告诉vue实例什么阶段要做什么事，比如初始化操作、网络请求\n	2. beforeCreate\n	3. created\n	4. ...\n\n## 插值操作\n	1. {{}} 插值操作mustache语法\n	2. v-once 表示元素或组件只渲染一次，不会随数据改变而改变\n	3. v-html=\'\' 将字符串按照html解析出来渲染\n	4. v-text=\'\' 与mustache语法类似将字符串文本直接渲染出来，不够灵活，会覆盖之前的文本\n	5. v-pre 将字符串原封不动显示出来\n	6. v-cloak 在vue解析之前有，vue解析之后会自动删除\n		[v-cloak] {\n			display: none;//使用样式让元素在vue未解析前隐藏\n		}\n## 动态绑定属性v-bind，缩写 ：\n	1. 在属性之前加:,表示该属性是动态的\n	2. 动态绑定class属性，可以绑定对象，也可以绑定数组\n	   绑定对象： :class=\"{类名:boolean}\"\n	   绑定数组： :class=\"[\'类名1\',\'类名2\']\"\n	3. 动态绑定style属性，可以绑定对象，也可以绑定数组\n	   绑定对象： :style=\"{属性名: 属性值}\"\n	   绑定数组： :style=\"[{属性名: 属性值},{属性名: 属性值}]\"\n## 计算属性\n	1. computed\n	2. 调用时不需要加()\n	3. 和methods相比，有缓存，多次调用的时候如果相关计算数据没有改变的话，只执行一次，而methods每次调用都会再次执行，效率较低\n	4. 本质上是对象，一般不设置set方法，调用的时候实际上是调用对象的get方法\n## 事件监听v-on 缩写@\n	1. 没有参数传递时，方法调用可以不加()\n	2. 在事件定义，方法需要一个参数时，如果调用时省略(),vue会默认将浏览器生成的event事件对象作为参数传入方法中\n	3. 方法定义时，需要event参数，同时需要其他参数时，调用方法时可以传入$event作为event参数的实参\n	4. 修饰符\n		1. .stop 阻止事件冒泡 相当于event.stopPropagation()\n		2. .prevent 阻止默认行为 相当于event.preventDefault()\n		3. .enter 监听键盘回车键\n		4. .native 监听组件根元素的原生事件\n		5. .once 只触发一次回调\n## 条件判断\n	1. v-if=\'true/false\'、v-else\n	2. v-show=\'true/false\'\n	3. v-show和v-if对比\n		1.v-if当条件为false时，不会渲染对应的dom元素\n		2.v-show当条件为false时，只是给dom元素添加了一个行内样式display:none;\n		3.当需要频繁切换显示与隐藏元素时，使用v-show，当只有一次切换时使用v-if\n#### 登录切换的input复用问题\n	vue在切换dom元素的时候会复用虚拟dom中的元素，出于性能考虑vue会对比这两个dom元素的差异，\n	如果其中的属性没有发生改变，则会复用之前的dom元素，如果想要使用新的dom元素，需要给这个dom元素指定一个key属性，来代表唯一性\n## 循环遍历v-for=\"\"\n	1. 循环遍历数组(value,index)\n	2. 遍历对象(value,key,index)\n	3. 注意：\n	使用v-for最好给每个dom元素添加key属性\n	这个其实和vue中虚拟DOM的Diff算法有关，diff算法默认执行过程是将需要插入位置的值更新为新的值，将它之后的值也进行逐个更新，然后将原本最后一个值放到末尾，这样效率较低\n	key的作用主要是为了高效的更新虚拟DOM，有了key，diff算法就可以正确识别该节点\n## 数组中哪些方法是响应式的\n	1. push\n	2. pop\n	3. shift\n	4. unshift\n	5. splice\n		1. 删除元素：第二个参数传入要删除几个元素，不传则删除后面所有元素\n		2. 替换元素：第二个参数传入要替换几个元素，之后的参数是替换的元素\n		3. 插入元素：第二个参数传0，之后的参数是插入的元素\n	6. sort\n	7. reverse\n#### 替换数组中的某个元素\n	1.arr.splice(要修改元素的下标,要修改多少个元素,修改后的值...)\n	2.Vue.set(要修改的对象或数组,索引值,修改后的值)\n## 过滤器\n	1. 需要执行过滤的表达式，作为参数传入过滤器中 | 过滤器()\n	2. filters\n## forEach、map、filter、reduce的区别\n	1.都会循环遍历数组中的每一项\n	2.map()、forEach()和filter()方法里每次执行匿名函数都支持3个参数，参数分别是：当前元素、当前元素的索引、当前元素所属的数组；\n	3.匿名函数中的this都是指向window；\n	4.只能遍历数组。\n	5.map()速度比forEach()快；\n	6.map()和filter()会返回一个新数组，不对原数组产生影响；forEach()不会产生新数组，返回undefined；reduce()函数是把数组缩减为一个值(比如求和、求积)；\n#### filter\n	1. 回调函数必须返回一个boolean值\n	2. 如果为true，则将这次回调的n加入新数组中\n	3. 循环结束返回一个新数组\n#### map\n	1. 回调函数返回一个元素计算表达式\n	2. 将每次计算表达式的结果统一放入一个新数组中返回\n#### reduce\n	1. 对数组中所有内容进行汇总\n	2. 第二个参数为初始值\n	3. 第一个参数是一个回调函数，回调函数中可以传入两个参数preValue和n，preValue是每次遍历返回的值，n数组中的每个元素\n\n\n## 表单绑定v-model\n	1. 实现表单元素和数据的双向绑定\n	2. 本质上是一个语法糖，包含了两个操作\n		1.通过v-bind绑定inoput的value属性\n		2.通过v-on指令给当前元素绑定input事件\n		<input type=\"text\" v-model=\"message\">\n		相当于\n		<input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\">\n#### v-model与单选框radio\n	v-model为input的value值\n#### v-model与复选框相结合checkbox\n	1.单个复选框，v-model为布尔值\n	2.多个复选框，v-model为数组，值为input中的value\n#### v-model与select\n	v-model的值为option中value的字符串(选单个)或者数组(选多个)\n#### 值绑定\n	本质上就是使用v-bind动态绑定value属性\n#### v-model修饰符\n	1  .lazy 当用户敲回车或者input失去焦点时绑定数据到data中\n	2  .number 将用户输入的值自动转成number类型\n	3  .trim\n\n## 组件化\n	将一个页面拆分成一个个小的功能块，每个功能块完成属于自己独立的功能，便于整个页面的管理和维护\n	1.创建组件构造器：Vue.extend() 传入template代表自定义组件模板\n		语法糖：可以直接省略调用Vue.extend()，直接将template传入组件注册的Vue.component()或components属性中\n		template模板的分离写法：\n			1.使用<script type=\"text/x-template\" id=\"\">\n			2.使用<template id=\"\"> \n	2.注册组件(全局)：Vue.component()	\n	两个参数：1、注册组件的标签名 2、组件构造器\n	3.使用组件：在vue实例的作用范围内使用组件\n	4.注册局部组件：创建vue实例(相当于最顶级父组件也就是根组件)时使用components属性 {标签名:组件构造器,标签名:组件构造器}\n	5.局部组件方式二：在父组件中使用components属性 {标签名:组件构造器,标签名:组件构造器}\n#### 组件自己的数据存放在哪\n	1.组件对象也有一个data，必须是一个函数\n	2.这个函数返回一个对象，对象内部保存数据\n	3.data为什么必须是一个函数？\n		因为每一个 vue 组件都是一个 vue 实例，通过 new Vue() 实例化，引用同一个对象，如果 data 直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同类型数据就会被改变，而 data 是函数的话，每次调用返回一个新对象，每个 vue 组件实例的 data 都因为是函数有了自己的作用域，所以互不干扰。	\n\n\n## 父子组件的通信\n	1.通过props向子组件传递数据\n		1.在子组件中使用props属性，可以是数组，也可以是对象，当需要对props进行类型等验证时，就可以使用对象\n		props: {\n		    cmessage: {\n			type: String,\n		        default: \'\',\n		        required: true\n		    }\n		}\n		2.在子组件中使用v-bind绑定父组件传递过来的数据，属性名为props中定义的名字，值为父组件的数据变量名\n	2.通过事件向父组件发送消息 $emit\n		1.在子组件中通过$emit(自定义事件名,传递的数据)来触发一个自定义事件，并传递数据\n		2.在父组件中，通过v-on监听子组件的自定义事件，接收的参数就是子组件传过来的数据\n## 父子组件的访问方式\n	1.父组件访问子组件：使用$children或$refs(常用，需要给子组件设置一个ref属性才能拿到)\n		this.$children是一个数组类型，包含所有子组件对象\n		this.$refs是一个对象类型，其中的key为子组件设置的ref属性的值\n	2.子组件访问父组件：使用$parent、$root(根组件)\n\n## 插槽slot\n	1. 组件的插槽是为了让我们封装的组件具有更强的扩展性\n	2. 组件模板中添加<slot>默认值</slot>\n	3. 使用的时候在组件标签中插入想要的东西，如果没有插入则显示默认值\n	4. 如果有多个值，同时放入组件中进行替换时，一起作为替换元素\n#### 具名插槽\n	<slot name=\"\">默认值</slot>\n	使用的时候再组件标签中的内容要有slot属性指向具名插槽的name属性的值\n#### 作用域插槽\n	父组件替换插槽的标签，但是数据内容由子组件来提供\n	1.子组件中的模板通过动态绑定属性向父组件传递数据\n		<slot :data=\"\"></slot>\n	2.父组件中使用\n		<template slot-scope=\"slot\">\n		    {{slot.data}}\n		</template>\n\n\n## runtime-compiler和runtime-only的区别\n	runtime-only相比runtime-compiler有两个优点：\n		1.运行效率高\n		2.源代码量更少\n		runtime-compiler的步骤：\n			template -> ast -> render -> virtual dom -> 真实dom\n		runtime-only的步骤：\n			render -> virtual dom -> 真实dom\n		3.如果开发中还使用template，选择runtime-compiler\n		4.如果开发中使用.vue文件，选择runtime-only\n## vue cli 脚手架\n	可以快速搭建vue开发环境以及对应的webpack配置\n\n## vuecli2和vuecli3初始化项目\n	1.vuecli2 \n		vue init webpack 项目名\n	2.vuecli3\n		vue create 项目名\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2021-06-19 11:04:31', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, 'http://127.0.0.1:3000\\uploads\\20210619\\1624071404943.jpg', 7, 0, 0);
INSERT INTO `article` VALUES (212, '复习阶段第九天', '继续vue的复习', '2021-06-20 10:37:43', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);
INSERT INTO `article` VALUES (213, 'vue进阶', '## 路由\n	路由就是通过互联的网络把信息从源地址传输到目的地址的活动\n	1. 路由是决定数据包从来源到目的地的路径\n	2. 转送将输入端的数据转移到合适的输出端\n## 后端渲染和前端渲染\n	1.后端路由阶段：后端处理URL和页面的映射关系，服务器直接生产渲染好对应的HTML页面，返回给客户端展示，代码难维护，复用性较低\n	2.前后端分离阶段：后端只负责提供数据，前端渲染，浏览器中显示的网页内容，都是由前端写的js代码在浏览器中执行，最终渲染到页面\n	3.前端路由阶段：SPA页面，整个网页只有一个html页面，前端路由管理url和组件的映射关系，前端路由核心：改变url，但是页面不进行整体刷新\n## vue-router\n	1.导入路由对象，并且调用Vue.use(VueRouter)\n	2.创建路由实例，并且传入路由映射配置\n	3.在Vue实例中挂载创建的路由实例\n#### 使用路由\n	1.创建路由组件\n	2.配置路由映射：组件和路径映射关系\n	3.使用：\n		1.声明式导航：通过<router-link>和<router-view>，默认渲染为a标签\n			to属性指定路由路径\n			replace属性指不会留下history记录\n		2.编程式导航：this.$router.push()/replace()\n#### 路由默认模式\n	路由默认模式是hash，通过在创建路由实例的配置mode:\"history\"改变模式为history\n#### 动态路由(路由路径不确定)\n	1. 配置路由时使用 /:id 可以匹配动态路由\n	2. 通过v-bind绑定to属性，路径可以拼接变量\n   	3. 使用$route可以得到当前活跃的路由，其中有params可以得到拼接的变量值\n#### 路由懒加载\n	把不同路由对应的组件分割成不同代码块，当路由被访问时才加载对应组件\n	() => import(路径)\n#### 路由嵌套\n	1.创建对应的子组件，并配置对应的子路由children\n	2.在组件内部使用<router-view>\n#### 参数传递方式\n	1.params\n		1.配置路由格式：/router/:id\n		2.传递的方式：在path后面拼上对应值\n		3.传递后的路径：/router/123\n		4.通过$route.params.id得到\n	2.query\n		1.配置路由格式：/router\n		2.传递方式：to属性的值可以是对象，其中使用query属性作为传递方式\n		3.传递后的路径：/router?id=123\n		4.通过$route.query.id得到\n#### 全局导航守卫\n	监听路由跳转事件\n	1.前置守卫：router.beforeEach((to,from,next)=>{})\n		to:到哪个路由去\n		from：从哪个路由来\n		next：函数，表示执行，后面如果有参数表示强制跳转到某个路径\n	2.后置钩子：router.afterEach((to,from)=>{})\n#### 路由独享守卫\n#### 组件内守卫\n\n\n#### keep-alive\n	keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染\n	1.exclude属性，匹配的组件都不会缓存\n	2.include属性，只有匹配的组件会缓存\n\n## Vuex\n	是一个专为vuejs应用程序开发的状态管理模式\n	1. 采取集中式存储管理应用的所有组件的状态，并以相应的规则保存状态，以一种可预测的方式发生变化\n	2. 例如：用户的登录状态、用户名称、头像、地理位置信息、商品收藏、购物车中的物品等等(响应式)\n#### 使用\n	1.Vue.use(Vuex)\n	2.const store = new Vuex.Store({\n		state:{\n			//保存状态信息，响应式 \n		},\n		mutations:{\n		    //方法，同步修改状态信息\n		},\n		actions:{\n			//异步操作\n		},\n		getters:{\n			//类似于组件中的计算属性\n		},\n		modules:{\n			//划分其他模块\n		}\n	})\n	3.在vue实例上挂载store\n		可以在全局使用$store.state\n	4.通过this.$store.state.属性的方式来访问状态\n	5.通过this.$store.commit(\'mutations中的方法\')来修改状态\n#### state单一状态树\n\n## Vue响应式原理\n	Vue最独特的特性之一就是响应式系统，当把一个普通的JavaScript对象传入vue实例作为data选项的时候，Vue会遍历此对象所有的property，\n	并使用Object.defineProperty方法把这些property转为getter/setter，这些getter/setter对用户来说是不可见的，但是在内部它们让Vue能够追踪依赖，在property被访问和修改时通知变更，每个组件实例都对应一个watcher实例，它会在组件渲染过程中把接触过的数据property记为依赖，\n	之后当依赖项的setter触发时，通知watcher，从而使它关联的组件重新渲染\n	1.对于已经创建的实例，Vue 不允许动态添加根级别的响应property。\n	  但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property\n	2.还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名\n	3.为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。\n	  这样回调函数将在 DOM 更新完成后被调用\n	4.在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上\n	\n#### 响应式原理理解\n	1. new Vue()\n	2. data数据 => Observer(用于监听劫持所有data属性),通过Object.defineProperty来实现\n	3. 通知变化 => 给每个监听到的data属性创建Dep对象\n	4. 每个Dep对象会添加订阅者Watcher\n	5. el模板根据Compile解析其中的指令,通知变化触发notify函数\n	6. 订阅数据发生变化，绑定更新函数，调用update()更新视图 ', '2021-06-20 16:09:54', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, '', 3, 0, 0);
INSERT INTO `article` VALUES (214, '复习第十天', '看项目', '2021-06-21 21:10:22', 31, 0, NULL, NULL, NULL, NULL, NULL, NULL, 1, NULL, 1, 0, 0);

SET FOREIGN_KEY_CHECKS = 1;
